<!--
@project: a/sdf-tunnel — neon SDF tunnel (WebGL ray-march)
@version: v0.1.1
@date: 2025-11-06 (Europe/Warsaw)
@blurb: WebGL SDF ray-marched ribbed tunnel with closer camera path, FPS, resolution selector, and fullscreen toggle.
-->
<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1">
<title>a/sdf-tunnel</title>
<script type="importmap">{"imports":{"@shared/":"../../shared/v1/"}}</script>
<style>
  html,body{margin:0;height:100%;background:#04060a;color:#cfd9e6;font:12px/1.4 ui-monospace,Consolas,monospace}
  #c{width:100vw;height:100vh;display:block}
  .hud{position:fixed;left:10px;top:10px;opacity:.85;background:rgba(0,0,0,.35);padding:6px 8px;border-radius:8px;border:1px solid #1a2230}
  .panel{position:fixed;right:10px;top:10px;background:rgba(0,0,0,.35);padding:8px;border-radius:10px;border:1px solid #1a2230}
  .panel label{display:block;margin-bottom:6px}
  .panel select,.panel button{font:12px ui-monospace,Consolas,monospace;background:#0d131d;color:#cfd9e6;border:1px solid #2a3340;border-radius:8px;padding:6px 8px}
  .panel button{display:block;margin-top:8px;width:100%}
</style>
</head>
<body>
<canvas id="c"></canvas>

<!-- UI -->
<div class="hud"><div id="fps">FPS: --</div><div id="ms">ms: --</div></div>
<div class="panel">
  <label>Resolution
    <select id="resSel">
      <option value="0.5">0.5×</option>
      <option value="0.75">0.75×</option>
      <option value="1" selected>1× (default)</option>
      <option value="1.5">1.5×</option>
      <option value="2">2×</option>
    </select>
  </label>
  <button id="fsBtn">Fullscreen</button>
</div>

<script type="module">
import { $$ } from '@shared/utils.js';

const canvas = document.getElementById('c');
const fpsEl = document.getElementById('fps');
const msEl  = document.getElementById('ms');
const resSel = document.getElementById('resSel');
const fsBtn  = document.getElementById('fsBtn');

let gl, program, U, t0 = performance.now();
let mouse = {x:0.0, y:0.0, down:false};
let scale = 1.0; // resolution scale (UI-controlled)

// ---------- Resize / resolution ----------
function fitCanvas(){
  const dpr = Math.max(1, Math.min(2, window.devicePixelRatio||1));
  const w = Math.floor(innerWidth * dpr * scale);
  const h = Math.floor(innerHeight * dpr * scale);
  if (canvas.width !== w || canvas.height !== h) {
    canvas.width = w; canvas.height = h;
    canvas.style.width = '100vw'; canvas.style.height = '100vh';
    if (gl) gl.viewport(0,0,w,h);
  }
}
resSel.addEventListener('change', ()=>{
  scale = parseFloat(resSel.value)||1.0;
  fitCanvas();
});

// ---------- Fullscreen ----------
fsBtn.addEventListener('click', async ()=>{
  if (!document.fullscreenElement) {
    await document.documentElement.requestFullscreen().catch(()=>{});
  } else {
    await document.exitFullscreen().catch(()=>{});
  }
});

// ---------- GLSL ----------
const VERT = `
attribute vec2 a_pos;
void main(){ gl_Position = vec4(a_pos,0.0,1.0); }
`;

// SDF tunnel: rounded, ribbed cylinder (clear circular ribs) with mild twist.
// Camera flies near the wall for a readable sense of scale.
const FRAG = `
precision highp float;

uniform vec2 u_res;
uniform float u_time;
uniform vec2 u_mouse; // -1..1

float hash21(vec2 p){ p = fract(p*vec2(123.34, 345.45)); p += dot(p, p+34.345); return fract(p.x*p.y); }
mat2 rot(float a){ float s=sin(a), c=cos(a); return mat2(c,-s,s,c); }

// Distance to thin, ribbed cylindrical wall
float sdTunnel(vec3 p){
  // mild twist by z to keep interest
  float twist = 0.25 * sin(0.35*p.z + 0.5*u_time);
  p.xy = rot(twist) * p.xy;

  // Base radius (clear circular cross-section)
  float baseR = 1.08;

  // Ribs along z: triangle wave drives radius mod
  float tile = 1.00;                         // distance between ribs
  float zt = abs(fract(p.z / tile) - 0.5) * 2.0; // 0..1
  float rib = 0.08 * (0.5 - smoothstep(0.35, 0.5, zt)); // rib bulge

  // Subtle breathing & undulation
  float breathe = 0.05 * sin(p.z*0.6 + u_time*1.2);

  // final radius for the wall
  float R = baseR + rib + breathe;

  // thin wall SDF: distance to surface of tube of radius R with thickness t
  float t = 0.028; // wall thickness
  float d = abs(length(p.xy) - R) - t;

  // micro bumping (very mild) to add grain
  d += (hash21(floor(p.xz*2.5))*2.0-1.0)*0.0025;
  return d;
}

vec3 normal(vec3 p){
  const float e=0.0015;
  vec2 k=vec2(1,-1);
  return normalize(
    k.xyy*sdTunnel(p + k.xyy*e) +
    k.yyx*sdTunnel(p + k.yyx*e) +
    k.yxy*sdTunnel(p + k.yxy*e) +
    k.xxx*sdTunnel(p + k.xxx*e)
  );
}

float softshadow(vec3 ro, vec3 rd){
  float t=0.02, res=1.0;
  for(int i=0;i<40;i++){
    float h = sdTunnel(ro + rd*t);
    res = min(res, 8.0*h/t);
    t += clamp(h, 0.02, 0.18);
    if (h < 0.00035) break;
  }
  return clamp(res, 0.0, 1.0);
}

void main(){
  vec2 uv = (gl_FragCoord.xy*2.0 - u_res) / min(u_res.x,u_res.y);

  // Closer camera: glide forward with small radial offset (near the wall)
  float t = u_time * 0.7;
  float roam = 0.28; // radial offset
  vec3 ro = vec3(roam*sin(t*0.8), roam*cos(t*0.9), t*2.2);
  vec3 ta = vec3(0.0, 0.0, ro.z + 1.2);

  // Mouse look (gentle)
  vec2 look = u_mouse * 0.5;
  ro.xy += vec2(look.y, -look.x)*0.25;
  ta.xy += vec2(look.y, -look.x)*0.25;

  // Camera basis
  vec3 ww = normalize(ta - ro);
  vec3 uu = normalize(cross(vec3(0,1,0), ww));
  vec3 vv = cross(ww, uu);
  vec3 rd = normalize(uu*uv.x + vv*uv.y + ww*1.0);

  // March
  float dist=0.0, tmax=38.0;
  vec3 p;
  float glow=0.0; bool hit=false;
  for(int i=0;i<180;i++){
    p = ro + rd*dist;
    float h = sdTunnel(p);
    glow += exp(-max(h,0.0)*55.0)*0.008;
    if (h<0.0009){ hit=true; break; }
    dist += h;
    if (dist>tmax) break;
  }

  vec3 col = vec3(0.02,0.03,0.05);
  if(hit){
    vec3 n = normal(p);
    vec3 ldir = normalize(vec3(0.6,0.85,0.25));
    float dif = clamp(dot(n, ldir), 0.0, 1.0);
    float sh  = softshadow(p + n*0.01, ldir);
    float spe = pow(max(dot(reflect(-ldir,n), -rd), 0.0), 32.0);

    // Neon stripes by angle and z — very clear ribs/trim
    float ang = atan(p.y, p.x);
    float stripes = 0.5 + 0.5*sin(ang*6.0 + p.z*1.2 + u_time*2.0);
    vec3 neon = mix(vec3(0.10,0.65,1.30), vec3(1.15,0.25,0.85), stripes);

    // Lighting
    col = neon * (0.10 + dif*sh*1.25) + spe*0.35;
  }

  // Add tunnel glow and tone map
  col += vec3(0.9,0.5,1.2) * pow(glow, 1.15);
  col = col / (1.0 + col);
  col = pow(col, vec3(0.4545)); // gamma 2.2

  gl_FragColor = vec4(col,1.0);
}
`;

// ---------- GL init ----------
function createGL(){
  gl = canvas.getContext('webgl', {antialias:false, depth:false, stencil:false, alpha:false, preserveDrawingBuffer:false});
  if(!gl){ alert('WebGL not supported'); return; }

  function comp(type, src){
    const s = gl.createShader(type); gl.shaderSource(s,src); gl.compileShader(s);
    if(!gl.getShaderParameter(s, gl.COMPILE_STATUS)){ throw new Error(gl.getShaderInfoLog(s)||'shader'); }
    return s;
  }
  const vs = comp(gl.VERTEX_SHADER, VERT);
  const fs = comp(gl.FRAGMENT_SHADER, FRAG);
  program = gl.createProgram();
  gl.attachShader(program, vs); gl.attachShader(program, fs); gl.linkProgram(program);
  if(!gl.getProgramParameter(program, gl.LINK_STATUS)){ throw new Error(gl.getProgramInfoLog(program)||'link'); }
  gl.useProgram(program);

  const buf = gl.createBuffer(); gl.bindBuffer(gl.ARRAY_BUFFER, buf);
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1,-1, 1,-1, -1,1,  -1,1, 1,-1, 1,1]), gl.STATIC_DRAW);
  const loc = gl.getAttribLocation(program, 'a_pos');
  gl.enableVertexAttribArray(loc); gl.vertexAttribPointer(loc, 2, gl.FLOAT, false, 0, 0);

  U = {
    u_res:  gl.getUniformLocation(program, 'u_res'),
    u_time: gl.getUniformLocation(program, 'u_time'),
    u_mouse:gl.getUniformLocation(program, 'u_mouse')
  };
}

// ---------- Frame / input / FPS ----------
let last = performance.now(), emaMs = 16.7;
function frame(){
  const now = performance.now();
  const dt = now - last; last = now;
  // Exponential moving average for smoother FPS readout
  emaMs = emaMs*0.9 + dt*0.1;
  const fps = 1000/emaMs;
  fpsEl.textContent = 'FPS: ' + fps.toFixed(0);
  msEl.textContent  = 'ms: ' + emaMs.toFixed(1);

  const t = (now - t0)/1000;
  gl.uniform2f(U.u_res, canvas.width, canvas.height);
  gl.uniform1f(U.u_time, t);
  gl.uniform2f(U.u_mouse, mouse.x, mouse.y);
  gl.drawArrays(gl.TRIANGLES, 0, 6);
  requestAnimationFrame(frame);
}

// Pointer look (drag)
canvas.addEventListener('pointerdown', ()=>{ mouse.down=true; });
canvas.addEventListener('pointerup',   ()=>{ mouse.down=false; });
canvas.addEventListener('pointerleave',()=>{ mouse.down=false; });
canvas.addEventListener('pointermove', (e)=>{
  if(!mouse.down) return;
  const nx = (e.movementX||0)/300;
  const ny = (e.movementY||0)/300;
  mouse.x = Math.max(-1, Math.min(1, mouse.x + nx));
  mouse.y = Math.max(-1, Math.min(1, mouse.y + ny));
});

$$.onReady(()=>{
  scale = parseFloat(resSel.value)||1.0;
  fitCanvas(); addEventListener('resize', fitCanvas);
  createGL(); frame();
});
</script>
</body>
</html>
