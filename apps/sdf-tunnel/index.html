<!--
@project: a/sdf-tunnel — neon SDF tunnel (WebGL ray-march)
@version: v0.1.0
@date: 2025-11-06 (Europe/Warsaw)
@blurb: Pure-HTML5 WebGL ray-marched neon tunnel using signed distance fields (SDF), soft shadows, and glow.
-->
<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1">
<title>a/sdf-tunnel</title>
<script type="importmap">{"imports":{"@shared/":"../../shared/v1/"}}</script>
<style>
  html,body{margin:0;height:100%;background:#04060a;color:#cfd9e6;font:14px/1.4 system-ui}
  #c{width:100vw;height:100vh;display:block}
  .hud{position:fixed;left:10px;bottom:10px;opacity:.7;font-size:12px}
</style>
</head>
<body>
<canvas id="c"></canvas>
<div class="hud">Drag to look · SDF Tunnel v0.1.0</div>

<script type="module">
import { $$ } from '@shared/utils.js';

const canvas = document.getElementById('c');
let gl, program, t0 = performance.now(), mouse = {x:0.0, y:0.0, down:false};

// Resize helper
function fitCanvas() {
  const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
  const w = Math.floor(innerWidth * dpr);
  const h = Math.floor(innerHeight * dpr);
  if (canvas.width !== w || canvas.height !== h) {
    canvas.width = w; canvas.height = h;
    canvas.style.width = '100vw'; canvas.style.height = '100vh';
    if (gl) gl.viewport(0,0,w,h);
  }
}

// GLSL
const VERT = `
attribute vec2 a_pos;
void main(){
  gl_Position = vec4(a_pos, 0.0, 1.0);
}
`;

const FRAG = `
precision highp float;

uniform vec2 u_res;
uniform float u_time;
uniform vec2 u_mouse; // -1..1

// Hash / noise helpers
float hash21(vec2 p){ p = fract(p*vec2(123.34, 345.45)); p += dot(p, p+34.345); return fract(p.x*p.y); }

// SDF primitives
float sdTorus(vec3 p, vec2 t){ vec2 q = vec2(length(p.xz)-t.x, p.y); return length(q)-t.y; }
float sdBox(vec3 p, vec3 b){ vec3 q = abs(p)-b; return length(max(q,0.0))+min(max(q.x,max(q.y,q.z)),0.0); }

// Rotate
mat2 rot(float a){ float s=sin(a), c=cos(a); return mat2(c,-s,s,c); }

// Scene SDF
float sdf(vec3 p){
  // Repeat space in Z to form a tunnel
  float tile = 6.0;
  p.z = mod(p.z, tile) - 0.5*tile;

  // Twisting tunnel
  float twist = 0.6*sin(0.5*p.z + u_time*0.8);
  p.xy = rot(twist)*p.xy;

  // Torus ring + inset box carvings
  float t = sdTorus(p, vec2(1.2, 0.15));
  float b = sdBox(p + vec3(0.0, 0.0, 1.8), vec3(0.25,0.25,0.5));
  float c = sdBox(p - vec3(0.8, 0.0,-1.2), vec3(0.2,0.2,0.6));

  // Union/subtract blend
  float d = min(t, max(-0.3, max(b, c)));

  // Micro bumps (cheap)
  d += (hash21(floor(p.xz*2.0))*2.0-1.0)*0.002;
  return d;
}

// Normal
vec3 normal(vec3 p){
  const float e=0.001;
  vec2 k=vec2(1,-1);
  return normalize(
    k.xyy*sdf(p + k.xyy*e) +
    k.yyx*sdf(p + k.yyx*e) +
    k.yxy*sdf(p + k.yxy*e) +
    k.xxx*sdf(p + k.xxx*e)
  );
}

// Soft shadow
float softshadow(vec3 ro, vec3 rd){
  float t=0.02, res=1.0;
  for(int i=0;i<40;i++){
    float h = sdf(ro + rd*t);
    res = min(res, 8.0*h/t);
    t += clamp(h, 0.02, 0.2);
    if (h < 0.0003) break;
  }
  return clamp(res, 0.0, 1.0);
}

void main(){
  vec2 uv = (gl_FragCoord.xy*2.0 - u_res)/min(u_res.x,u_res.y);

  // Camera path (snake through space)
  float t = u_time*0.6;
  vec3 ro = vec3( 1.6*sin(t*0.7), 0.8*sin(t*0.9), t*3.0 );
  vec3 ta = ro + vec3(0.0, 0.0, 3.0);

  // Mouse look (add small offsets)
  vec2 look = u_mouse*0.6;
  ro.xy += vec2(look.y, -look.x);
  ta.xy += vec2(look.y, -look.x);

  // Camera basis
  vec3 ww = normalize(ta - ro);
  vec3 uu = normalize(cross(vec3(0,1,0), ww));
  vec3 vv = cross(ww, uu);
  vec3 rd = normalize(uu*uv.x + vv*uv.y + ww*1.6);

  // Ray march
  float tmax = 40.0;
  float dist=0.0;
  vec3 p;
  float glow = 0.0;
  bool hit=false;
  for(int i=0;i<160;i++){
    p = ro + rd*dist;
    float h = sdf(p);
    glow += exp(-h*40.0)*0.008;
    if (h<0.001){ hit=true; break; }
    dist += h;
    if (dist>tmax) break;
  }

  vec3 col = vec3(0.02,0.03,0.05); // background
  if(hit){
    vec3 n = normal(p);
    vec3 ldir = normalize(vec3(0.6,0.9,0.2));
    float dif = clamp(dot(n, ldir), 0.0, 1.0);
    float sh = softshadow(p + n*0.01, ldir);
    float spe = pow(max(dot(reflect(-ldir,n), -rd), 0.0), 32.0);

    // Neon bands by z-position
    float bands = 0.5 + 0.5*sin(p.z*2.0 + u_time*2.0);
    vec3 neon = mix(vec3(0.1,0.7,1.4), vec3(1.2,0.2,0.8), bands);

    col = neon * (dif*sh*1.2 + 0.08) + spe*0.4;
  }

  // Add tunnel glow
  col += vec3(0.9,0.5,1.2) * pow(glow, 1.2);

  // Tone map & gamma
  col = col / (1.0 + col);
  col = pow(col, vec3(0.4545)); // gamma 2.2

  gl_FragColor = vec4(col,1.0);
}
`;

function createGL(){
  gl = canvas.getContext('webgl', {antialias:false, depth:false, stencil:false, alpha:false, preserveDrawingBuffer:false});
  if(!gl){ alert('WebGL not supported'); return; }
  function comp(type, src){
    const s = gl.createShader(type); gl.shaderSource(s,src); gl.compileShader(s);
    if(!gl.getShaderParameter(s, gl.COMPILE_STATUS)){ throw new Error(gl.getShaderInfoLog(s)||'shader'); }
    return s;
  }
  const vs = comp(gl.VERTEX_SHADER, VERT);
  const fs = comp(gl.FRAGMENT_SHADER, FRAG);
  program = gl.createProgram();
  gl.attachShader(program, vs); gl.attachShader(program, fs); gl.linkProgram(program);
  if(!gl.getProgramParameter(program, gl.LINK_STATUS)){ throw new Error(gl.getProgramInfoLog(program)||'link'); }
  gl.useProgram(program);

  const buf = gl.createBuffer(); gl.bindBuffer(gl.ARRAY_BUFFER, buf);
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1,-1,  1,-1, -1,1,  -1,1, 1,-1, 1,1]), gl.STATIC_DRAW);
  const loc = gl.getAttribLocation(program, 'a_pos');
  gl.enableVertexAttribArray(loc); gl.vertexAttribPointer(loc, 2, gl.FLOAT, false, 0, 0);
}

function uniforms(){
  const u_res = gl.getUniformLocation(program, 'u_res');
  const u_time = gl.getUniformLocation(program, 'u_time');
  const u_mouse = gl.getUniformLocation(program, 'u_mouse');
  return { u_res, u_time, u_mouse };
}

let U;
function frame(){
  const now = performance.now();
  const t = (now - t0)/1000;
  gl.uniform2f(U.u_res, canvas.width, canvas.height);
  gl.uniform1f(U.u_time, t);
  gl.uniform2f(U.u_mouse, mouse.x, mouse.y);
  gl.drawArrays(gl.TRIANGLES, 0, 6);
  requestAnimationFrame(frame);
}

// Input
canvas.addEventListener('pointerdown', e=>{ mouse.down=true; });
canvas.addEventListener('pointerup',   e=>{ mouse.down=false; });
canvas.addEventListener('pointermove', e=>{
  if(!mouse.down) return;
  const nx = (e.movementX || 0)/300;
  const ny = (e.movementY || 0)/300;
  mouse.x = Math.max(-1, Math.min(1, mouse.x + nx));
  mouse.y = Math.max(-1, Math.min(1, mouse.y + ny));
});

$$.onReady(()=>{
  fitCanvas(); addEventListener('resize', fitCanvas);
  createGL(); U = uniforms(); frame();
});
</script>
</body>
</html>
