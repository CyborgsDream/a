<!--
@project: a/hills-forest — meters-true grassy hills with trees (Three.js)
@version: v0.1.0
@date: 2025-11-06 (Europe/Warsaw)
@blurb: 1 unit = 1 meter. Free-flight camera (WASD, mouse-look). Terrain from fractal value-noise; instanced trees; HUD with FPS/pos/speed.
-->
<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1">
<title>a/hills-forest</title>
<style>
  html,body{margin:0;height:100%;background:#0b0f14;color:#e9eef4;font:12px ui-monospace,Consolas,monospace;overscroll-behavior:none}
  canvas{display:block}
  .hud{position:fixed;left:10px;top:10px;background:rgba(0,0,0,.35);border:1px solid #1a2230;border-radius:8px;padding:6px 8px;line-height:1.35}
  .hint{position:fixed;left:10px;bottom:10px;opacity:.8}
</style>
</head>
<body>
<div class="hud" id="hud">FPS -- | pos -- -- -- | v -- m/s</div>
<div class="hint">Click to lock pointer · WASD move · mouse look · Space up · Ctrl down</div>

<script type="module">
import * as THREE from 'https://unpkg.com/three@0.160.0/build/three.module.js';

////////////////////////////////////////////////////////////////////////////////
// Config
////////////////////////////////////////////////////////////////////////////////
const WORLD_SIZE = 400;          // meters (square world, -200..+200)
const GRID_SEGS  = 256;          // terrain resolution (≈ 1.56 m spacing)
const HEIGHT_MAX = 18;           // meters peak-to-valley
const TREE_COUNT = 700;          // number of trees
const MIN_CAM_ALT = 1.7;         // "eye" above ground, meters
const SUN_DIR = new THREE.Vector3(0.6, 1.0, 0.4).normalize();

////////////////////////////////////////////////////////////////////////////////
// Scene, Renderer, Camera
////////////////////////////////////////////////////////////////////////////////
const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setPixelRatio(Math.min(2, devicePixelRatio||1));
renderer.setSize(innerWidth, innerHeight);
renderer.shadowMap.enabled = true;
renderer.shadowMap.type = THREE.PCFSoftShadowMap;
renderer.outputColorSpace = THREE.SRGBColorSpace;
renderer.toneMapping = THREE.ACESFilmicToneMapping;
document.body.appendChild(renderer.domElement);

const scene = new THREE.Scene();
scene.background = new THREE.Color(0x0b0f14);
scene.fog = new THREE.Fog(0x0b0f14, 120, 420);

const camera = new THREE.PerspectiveCamera(70, innerWidth/innerHeight, 0.1, 1200);
camera.position.set(0, 12, 0); // start 12 m above (ground clamp will fix it)

////////////////////////////////////////////////////////////////////////////////
// Lights
////////////////////////////////////////////////////////////////////////////////
const hemi = new THREE.HemisphereLight(0xbfd6ff, 0x2a3a2a, 0.6);
scene.add(hemi);

const sun = new THREE.DirectionalLight(0xfff5e1, 1.1);
sun.position.copy(SUN_DIR).multiplyScalar(200);
sun.castShadow = true;
sun.shadow.mapSize.set(1024,1024);
sun.shadow.camera.near = 10;
sun.shadow.camera.far  = 500;
sun.shadow.camera.left = -200; sun.shadow.camera.right = 200;
sun.shadow.camera.top  = 200;  sun.shadow.camera.bottom = -200;
scene.add(sun);

////////////////////////////////////////////////////////////////////////////////
// Value-noise height field (fast, tiny)
////////////////////////////////////////////////////////////////////////////////
const SEED = 1337;
function rand2(i, j){
  let x = Math.sin(i*127.1 + j*311.7 + SEED*0.01) * 43758.5453;
  return x - Math.floor(x);
}
function lerp(a,b,t){ return a + (b-a)*t; }
function smooth(t){ return t*t*(3-2*t); }
function valueNoise2(x, z){
  const xi=Math.floor(x), zi=Math.floor(z);
  const xf=x-xi, zf=z-zi;
  const v00 = rand2(xi,zi),     v10 = rand2(xi+1,zi);
  const v01 = rand2(xi,zi+1),   v11 = rand2(xi+1,zi+1);
  const vx0 = lerp(v00, v10, smooth(xf));
  const vx1 = lerp(v01, v11, smooth(xf));
  return lerp(vx0, vx1, smooth(zf));
}
// Fractal Brownian motion (4 octaves)
function fbm(x,z){
  let a=0, f=0.02, amp=1.0, sum=0, norm=0;
  for(let i=0;i<4;i++){
    a = valueNoise2(x*f, z*f);
    sum += a*amp; norm += amp;
    f *= 2.2; amp *= 0.48;
  }
  return sum/norm;
}
// Height at world coord (meters)
function heightAt(x,z){
  // Domain shift to positive for noise
  const h = fbm(x+1000, z+1000);
  return (h-0.5)*HEIGHT_MAX; // center around 0
}

////////////////////////////////////////////////////////////////////////////////
/* Terrain mesh (1 unit = 1 meter) */
////////////////////////////////////////////////////////////////////////////////
const geo = new THREE.PlaneGeometry(WORLD_SIZE, WORLD_SIZE, GRID_SEGS, GRID_SEGS);
geo.rotateX(-Math.PI/2);

// Displace Y by heightAt (meters)
const pos = geo.attributes.position;
for(let i=0;i<pos.count;i++){
  const x = pos.getX(i);
  const z = pos.getZ(i);
  pos.setY(i, heightAt(x, z));
}
geo.computeVertexNormals();

// Vertex colors (grass by height + slope)
const colors = new Float32Array(pos.count*3);
const c = new THREE.Color();
for(let i=0;i<pos.count;i++){
  const y = pos.getY(i);
  // slope clue via normal y
  const ny = geo.attributes.normal.getY(i);
  const slope = 1 - THREE.MathUtils.clamp(ny, 0, 1);
  // base green with slight variation by height
  const t = THREE.MathUtils.clamp((y + HEIGHT_MAX*0.5)/HEIGHT_MAX, 0, 1);
  c.setHSL(0.33 - 0.04*slope, 0.6, 0.35 + 0.15*t);
  colors[i*3+0] = c.r; colors[i*3+1] = c.g; colors[i*3+2] = c.b;
}
geo.setAttribute('color', new THREE.BufferAttribute(colors, 3));

const mat = new THREE.MeshLambertMaterial({vertexColors:true});
const terrain = new THREE.Mesh(geo, mat);
terrain.receiveShadow = true;
scene.add(terrain);

////////////////////////////////////////////////////////////////////////////////
// Instanced trees (trunk + crown)
////////////////////////////////////////////////////////////////////////////////
const trunkGeo = new THREE.CylinderGeometry(0.12, 0.18, 3.8, 8);
const crownGeo = new THREE.ConeGeometry(1.1, 2.2, 8);
trunkGeo.translate(0, 3.8/2, 0);
crownGeo.translate(0, 3.8 + 2.2/2, 0);

const trunkMat = new THREE.MeshStandardMaterial({color:0x5a3e2a, roughness:0.95, metalness:0});
const crownMat = new THREE.MeshStandardMaterial({color:0x2b7a3a, roughness:0.8, metalness:0});

const trunks = new THREE.InstancedMesh(trunkGeo, trunkMat, TREE_COUNT);
const crowns = new THREE.InstancedMesh(crownGeo, crownMat, TREE_COUNT);
trunks.castShadow = true; crowns.castShadow = true; crowns.receiveShadow = true;
scene.add(trunks); scene.add(crowns);

const m = new THREE.Matrix4();
const v3 = new THREE.Vector3();
let placed = 0;
const HALF = WORLD_SIZE*0.5;

// helper: slope magnitude at (x,z)
function slopeAt(x,z){
  const e=0.5;
  const h = heightAt(x,z);
  const hx = heightAt(x+e,z)-heightAt(x-e,z);
  const hz = heightAt(x,z+e)-heightAt(x,z-e);
  return Math.sqrt(hx*hx+hz*hz); // ≈ gradient magnitude
}

while(placed < TREE_COUNT){
  const x = THREE.MathUtils.randFloatSpread(WORLD_SIZE*0.95);
  const z = THREE.MathUtils.randFloatSpread(WORLD_SIZE*0.95);
  const y = heightAt(x,z);

  // constraints: not too steep, not too high/low
  const grad = slopeAt(x,z);
  if (grad > 1.2) continue;            // skip steep slopes
  if (y < -HEIGHT_MAX*0.45) continue;  // avoid valleys too low

  const yaw = Math.random()*Math.PI*2;
  const s = THREE.MathUtils.randFloat(0.85, 1.35);

  m.makeRotationY(yaw).setPosition(x, y, z).scale(v3.set(s,s,s));
  trunks.setMatrixAt(placed, m);
  crowns.setMatrixAt(placed, m);
  placed++;
}
trunks.instanceMatrix.needsUpdate = true;
crowns.instanceMatrix.needsUpdate = true;

////////////////////////////////////////////////////////////////////////////////
// Free-flight controls (pointer lock + WASD)
////////////////////////////////////////////////////////////////////////////////
const keys = new Set();
let lookX = 0, lookY = 0; // radians
let vel = new THREE.Vector3();        // m/s
const ACCEL = 22;                     // m/s^2
const DAMP  = 0.90;                   // velocity damping per frame (air "friction")
const MAX_SPEED = 18;                 // m/s

function lockPointer(){
  if (!document.pointerLockElement) document.body.requestPointerLock();
}
addEventListener('click', lockPointer);
addEventListener('pointerlockchange', ()=>{ /* no-op */ });

addEventListener('mousemove', (e)=>{
  if (!document.pointerLockElement) return;
  const sens = 0.0022;
  lookX -= e.movementX * sens;
  lookY -= e.movementY * sens;
  lookY = Math.max(-Math.PI/2+0.01, Math.min(Math.PI/2-0.01, lookY));
});

addEventListener('keydown', (e)=>{ keys.add(e.code); });
addEventListener('keyup',   (e)=>{ keys.delete(e.code); });

function updateControls(dt){
  // Build local movement vector
  const dir = new THREE.Vector3();
  if (keys.has('KeyW')) dir.z -= 1;
  if (keys.has('KeyS')) dir.z += 1;
  if (keys.has('KeyA')) dir.x -= 1;
  if (keys.has('KeyD')) dir.x += 1;
  if (keys.has('Space')) dir.y += 1;
  if (keys.has('ControlLeft') || keys.has('ControlRight')) dir.y -= 1;
  if (dir.lengthSq()>0) dir.normalize();

  // Camera basis from look angles
  const cosY = Math.cos(lookY), sinY = Math.sin(lookY);
  const cosX = Math.cos(lookX), sinX = Math.sin(lookX);
  const forward = new THREE.Vector3(-sinX*cosY, sinY, -cosX*cosY);
  const right   = new THREE.Vector3(cosX, 0, -sinX);
  const up      = new THREE.Vector3().crossVectors(right, forward).normalize();

  // Acceleration
  const accel = new THREE.Vector3();
  accel.addScaledVector(forward, dir.z*ACCEL);
  accel.addScaledVector(right,   dir.x*ACCEL);
  accel.addScaledVector(up,      dir.y*ACCEL);

  vel.addScaledVector(accel, dt);
  // Clamp speed
  if (vel.length() > MAX_SPEED) vel.setLength(MAX_SPEED);

  // Integrate
  camera.position.addScaledVector(vel, dt);

  // Soft damping
  vel.multiplyScalar(Math.pow(DAMP, (dt*60)));

  // Keep near ground if below
  const ground = heightAt(camera.position.x, camera.position.z) + MIN_CAM_ALT;
  if (camera.position.y < ground) camera.position.y = ground;

  // Apply look
  const target = new THREE.Vector3(
    camera.position.x - Math.sin(lookX)*Math.cos(lookY),
    camera.position.y + Math.sin(lookY),
    camera.position.z - Math.cos(lookX)*Math.cos(lookY)
  );
  camera.lookAt(target);
}

////////////////////////////////////////////////////////////////////////////////
// Resize
////////////////////////////////////////////////////////////////////////////////
function onResize(){
  renderer.setSize(innerWidth, innerHeight);
  camera.aspect = innerWidth/innerHeight;
  camera.updateProjectionMatrix();
}
addEventListener('resize', onResize);

////////////////////////////////////////////////////////////////////////////////
// Loop + HUD
////////////////////////////////////////////////////////////////////////////////
const hud = document.getElementById('hud');
let last = performance.now(), ema = 16.7;

function loop(){
  const now = performance.now();
  const dt = (now - last)/1000; last = now;
  ema = ema*0.9 + (dt*1000)*0.1;
  const fps = 1000/ema;

  updateControls(Math.min(dt, 0.05));
  renderer.render(scene, camera);

  const p = camera.position;
  const speed = vel.length();
  hud.textContent = `FPS ${fps.toFixed(0)} | pos ${p.x.toFixed(1)} ${p.y.toFixed(1)} ${p.z.toFixed(1)} | v ${speed.toFixed(1)} m/s`;

  requestAnimationFrame(loop);
}

// Start at safe altitude
camera.position.y = heightAt(camera.position.x, camera.position.z) + 10;
loop();
</script>
</body>
</html>
