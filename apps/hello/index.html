<!--
@project: a/hello — sample mini-app
@version: v1.2.0
@date: 2025-11-07 (Europe/Warsaw)
@blurb: Descend into an abyssal greeting awash in bioluminescent light and drifting mist.
-->
<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1">
<title>a/hello</title>
<script type="importmap">{
  "imports": { "@shared/": "../../shared/v1/" }
}</script>
<style>
  :root{
    color-scheme: dark;
    font-family: "Space Grotesk", "Segoe UI", system-ui, sans-serif;
  }
  body{
    margin:0;
    min-height:100dvh;
    background:radial-gradient(circle at 50% 20%,rgba(2,20,35,.9),rgba(0,9,20,.96) 48%,rgba(0,4,10,1));
    color:#dff7ff;
    overflow:hidden;
  }
  #scene{
    position:fixed;
    inset:0;
    z-index:0;
  }
  #scene canvas{display:block;width:100%;height:100%;}
  #hud{
    position:relative;
    z-index:1;
    display:grid;
    place-items:center;
    text-align:center;
    padding:4rem clamp(2rem,4vw,5rem);
    height:100dvh;
    pointer-events:none;
  }
  #hud::before{
    content:"";
    position:absolute;
    inset:18% 22%;
    border-radius:38px;
    background:linear-gradient(140deg,rgba(20,130,200,.18),rgba(0,220,200,.06));
    box-shadow:0 0 120px rgba(0,180,255,.2);
    filter:blur(70px);
    z-index:-1;
  }
  h1{
    margin:0 0 .5rem;
    font-size:clamp(2.8rem,7vw,5.4rem);
    letter-spacing:.08em;
    text-transform:uppercase;
    text-shadow:0 0 45px rgba(40,220,255,.88);
    position:relative;
    display:inline-block;
    --lens-x:50%;
    --lens-y:50%;
    --lens-strength:0;
  }
  h1::after{
    content:"";
    position:absolute;
    inset:-18%;
    border-radius:50%;
    background:radial-gradient(circle at var(--lens-x) var(--lens-y),rgba(80,190,255,.75),rgba(0,255,205,.4) 30%,rgba(0,80,140,.08) 60%,rgba(0,0,0,0) 80%);
    filter:blur(10px) saturate(1.4);
    mix-blend-mode:screen;
    opacity:calc(var(--lens-strength) * .85);
    transition:opacity .22s ease;
    pointer-events:none;
  }
  p{
    margin:0;
    max-width:28rem;
    line-height:1.6;
    font-size:clamp(1.05rem,2.2vw,1.35rem);
    color:rgba(190,232,255,.82);
  }
  #ui-overlay{
    position:fixed;
    inset:0;
    display:flex;
    flex-direction:column;
    justify-content:space-between;
    padding:1.25rem clamp(1rem,2.4vw,2.5rem);
    pointer-events:none;
    z-index:2;
    color:#e9fbff;
    font-size:.85rem;
    letter-spacing:.04em;
  }
  #ui-top{
    display:flex;
    justify-content:space-between;
    align-items:flex-start;
    gap:1rem;
  }
  .badge{
    pointer-events:auto;
    background:linear-gradient(135deg,rgba(16,128,255,.4),rgba(32,255,220,.25));
    border:1px solid rgba(80,200,255,.5);
    padding:.35rem .8rem;
    border-radius:999px;
    font-weight:600;
    text-transform:uppercase;
    box-shadow:0 0 18px rgba(0,200,255,.4);
    backdrop-filter:blur(12px);
  }
  #control-panel{
    pointer-events:auto;
    display:grid;
    justify-items:end;
    gap:.55rem;
    padding:.8rem 1rem;
    border-radius:18px;
    background:linear-gradient(160deg,rgba(4,28,48,.72),rgba(0,12,24,.82));
    border:1px solid rgba(32,180,255,.32);
    box-shadow:0 0 32px rgba(0,128,255,.25);
    min-width:200px;
  }
  #control-panel label{
    display:flex;
    align-items:center;
    gap:.6rem;
    font-size:.82rem;
    text-transform:uppercase;
  }
  #control-panel select,
  #control-panel button{
    font:inherit;
    color:inherit;
    background:rgba(0,30,60,.65);
    border:1px solid rgba(40,210,255,.45);
    border-radius:12px;
    padding:.4rem .7rem;
    text-transform:uppercase;
    letter-spacing:.08em;
    cursor:pointer;
    transition:background .2s ease,transform .2s ease;
  }
  #control-panel select:focus,
  #control-panel button:focus{
    outline:2px solid rgba(72,240,255,.75);
    outline-offset:2px;
  }
  #control-panel button:hover,
  #control-panel select:hover{
    background:rgba(0,48,90,.85);
    transform:translateY(-1px);
  }
  #legend{
    display:grid;
    gap:.35rem;
    font-size:.78rem;
    text-transform:uppercase;
  }
  #legend strong{color:rgba(120,240,255,.95);font-weight:600;}
  #status-line{
    font-size:.74rem;
    color:rgba(180,240,255,.75);
    text-transform:uppercase;
  }
  @media (max-width:768px){
    #ui-overlay{padding:1rem;gap:1rem;font-size:.78rem;}
    #control-panel{width:100%;justify-items:stretch;min-width:0;}
    #control-panel label{justify-content:space-between;}
    #control-panel select,#control-panel button{width:100%;}
    #ui-top{flex-direction:column;align-items:flex-start;}
  }
</style>
</head>
<body>
<div id="scene"></div>
<div id="ui-overlay">
  <div id="ui-top">
    <div class="badge" aria-label="Framework Pass">FPas</div>
    <div id="control-panel" aria-live="polite">
      <label for="resolution-select">Resolution
        <select id="resolution-select">
          <option value="auto">Auto adaptive</option>
          <option value="1.25">High (1.25×)</option>
          <option value="1">Standard (1×)</option>
          <option value="0.75">Performance (0.75×)</option>
          <option value="0.5">Ultra performance (0.5×)</option>
        </select>
      </label>
      <button type="button" id="fullscreen-toggle">Enter fullscreen</button>
      <button type="button" id="gyro-calibrate">Calibrate gyroscope</button>
      <div id="legend">
        <strong>Navigation</strong>
        <span>Space — Toggle motion</span>
        <span>Pointer — Lens focus sweep</span>
        <span>Auto-orbit camera — Cinematic glide</span>
      </div>
      <div id="status-line">Gyroscope idle</div>
    </div>
  </div>
</div>
<div id="hud">
  <div>
    <h1>Greetings from the abyss</h1>
    <p>Descend through sonar pulses and veils of vapor, guided by neon beacons that sweep the endless deep.</p>
  </div>
</div>
<script type="module">
import { $$ } from '@shared/utils.js';
import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.161.0/build/three.module.js';

$$.onReady(() => {
  const container = document.getElementById('scene');
  const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
  const isMobile = /Mobi|Android|iPhone|iPad|iPod/i.test(navigator.userAgent) || window.matchMedia('(max-width: 768px)').matches;
  const resolutionSelect = document.getElementById('resolution-select');
  const fullscreenToggle = document.getElementById('fullscreen-toggle');
  const gyroButton = document.getElementById('gyro-calibrate');
  const statusLine = document.getElementById('status-line');
  const pixelRatioLimits = {
    auto(){
      const cap = isMobile ? 1.1 : 1.7;
      return Math.min(window.devicePixelRatio || 1, cap);
    },
    fixed(value){
      return value;
    }
  };
  function applyResolution(value){
    const ratio = value === 'auto' ? pixelRatioLimits.auto() : pixelRatioLimits.fixed(parseFloat(value));
    renderer.setPixelRatio(ratio);
    renderer.setSize(window.innerWidth, window.innerHeight, false);
    backgroundTarget.setSize(window.innerWidth * ratio, window.innerHeight * ratio);
  }
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.outputColorSpace = THREE.SRGBColorSpace;
  container.appendChild(renderer.domElement);

  const scene = new THREE.Scene();
  scene.fog = new THREE.FogExp2(0x01070f, 0.22);

  const camera = new THREE.PerspectiveCamera(52, window.innerWidth / window.innerHeight, 0.1, 200);
  camera.position.set(0.35, 0.45, 5.6);

  const heading = document.querySelector('#hud h1');

  const ambient = new THREE.AmbientLight(0x10263b, 0.9);
  const hemisphere = new THREE.HemisphereLight(0x1a4872, 0x01040a, 0.6);
  const keyLight = new THREE.PointLight(0x14a7ff, 2.2, 24, 1.7);
  keyLight.position.set(3.6, 2.8, 4.3);
  const rimLight = new THREE.PointLight(0x0fffd7, 1.5, 20, 1.6);
  rimLight.position.set(-3.4, -1.2, -2.6);
  scene.add(ambient, hemisphere, keyLight, rimLight);

  const searchlightGroup = new THREE.Group();
  const searchlightRigs = [];
  const searchlightColors = [0x12e9ff, 0x1ab5ff, 0x25ffd6];
  searchlightColors.forEach((color, index) => {
    const rig = new THREE.Group();
    const angle = (index / searchlightColors.length) * Math.PI * 2;
    rig.position.set(Math.cos(angle) * 4.8, 1.1 + Math.sin(angle * 1.5) * 0.4, Math.sin(angle) * 4.8);

    const target = new THREE.Object3D();
    target.position.set(0, -1.5, 0);
    rig.add(target);

    const spotlight = new THREE.SpotLight(color, 3.4, 20, Math.PI / 5.4, 0.52, 1.6);
    spotlight.position.set(0, 0, 0);
    spotlight.target = target;
    rig.add(spotlight);

    const beam = new THREE.Mesh(
      new THREE.ConeGeometry(0.95, 6.8, 48, 1, true),
      new THREE.MeshBasicMaterial({
        color,
        transparent: true,
        opacity: 0.2,
        blending: THREE.AdditiveBlending,
        depthWrite: false,
        side: THREE.DoubleSide
      })
    );
    beam.position.set(0, -3.4, 0);
    beam.rotation.x = Math.PI;
    rig.add(beam);

    searchlightRigs.push({ rig, spotlight, beam, target, phase: Math.random() * Math.PI * 2 });
    searchlightGroup.add(rig);
  });
  scene.add(searchlightGroup);

  const glimmerCount = isMobile ? 780 : 1400;
  const glimmerGeometry = new THREE.BufferGeometry();
  const glimmerPositions = new Float32Array(glimmerCount * 3);
  for (let i = 0; i < glimmerCount; i++) {
    const radius = 10 + Math.random() * 18;
    const theta = Math.random() * Math.PI * 2;
    const phi = Math.acos(2 * Math.random() - 1);
    glimmerPositions[i * 3] = radius * Math.sin(phi) * Math.cos(theta);
    glimmerPositions[i * 3 + 1] = radius * Math.cos(phi) * 0.7;
    glimmerPositions[i * 3 + 2] = radius * Math.sin(phi) * Math.sin(theta);
  }
  glimmerGeometry.setAttribute('position', new THREE.Float32BufferAttribute(glimmerPositions, 3));
  const glimmerMaterial = new THREE.PointsMaterial({
    color: 0x5cf7ff,
    size: 0.06,
    sizeAttenuation: true,
    transparent: true,
    opacity: 0.85,
    depthWrite: false,
    blending: THREE.AdditiveBlending
  });
  const glimmerField = new THREE.Points(glimmerGeometry, glimmerMaterial);
  scene.add(glimmerField);

  const backdrop = new THREE.Mesh(
    new THREE.SphereGeometry(55, 48, 48),
    new THREE.MeshBasicMaterial({ color: 0x010307, side: THREE.BackSide, fog: false })
  );
  scene.add(backdrop);

  const backgroundTarget = new THREE.WebGLRenderTarget(
    window.innerWidth * renderer.getPixelRatio(),
    window.innerHeight * renderer.getPixelRatio(),
    { depthBuffer: false }
  );
  backgroundTarget.texture.colorSpace = THREE.SRGBColorSpace;

  const portalMaterial = new THREE.ShaderMaterial({
    uniforms: {
      uTime: { value: 0 },
      uColor1: { value: new THREE.Color(0x022c45) },
      uColor2: { value: new THREE.Color(0x16ffe3) }
    },
    vertexShader: `
      varying vec2 vUv;
      uniform float uTime;
      void main(){
        vUv = uv;
        float pulse = sin((uv.x + uv.y + uTime * 0.6) * 7.0);
        vec3 displaced = position + normal * (0.18 + pulse * 0.04);
        gl_Position = projectionMatrix * modelViewMatrix * vec4(displaced, 1.0);
      }
    `,
    fragmentShader: `
      varying vec2 vUv;
      uniform float uTime;
      uniform vec3 uColor1;
      uniform vec3 uColor2;
      void main(){
        float wave = sin((vUv.x * 2.2 + vUv.y * 2.8 + uTime * 1.1) * 4.0);
        float radial = smoothstep(1.0, 0.22, length(vUv - 0.5));
        vec3 color = mix(uColor1, uColor2, clamp(vUv.y + wave * 0.1, 0.0, 1.0));
        color += radial * 0.45;
        gl_FragColor = vec4(color, radial);
      }
    `,
    transparent: true,
    side: THREE.DoubleSide
  });
  const portal = new THREE.Mesh(new THREE.RingGeometry(1.4, 2.4, 128, 48), portalMaterial);
  portal.rotation.x = Math.PI / 2;
  scene.add(portal);

  const torus = new THREE.Mesh(
    new THREE.TorusKnotGeometry(1, 0.32, 320, 48, 2, 5),
    new THREE.MeshStandardMaterial({
      color: 0x12d8ff,
      metalness: 0.45,
      roughness: 0.22,
      emissive: 0x045d91,
      emissiveIntensity: 1.4
    })
  );
  scene.add(torus);

  const orbGeometry = new THREE.IcosahedronGeometry(0.82, 4);
  const orbMaterial = new THREE.ShaderMaterial({
    uniforms: {
      uSceneTexture: { value: backgroundTarget.texture },
      uStrength: { value: 0.24 },
      uTime: { value: 0 },
      uGlowColor: { value: new THREE.Color(0x1fffe1) },
      uHighlightColor: { value: new THREE.Color(0x1488ff) }
    },
    vertexShader: `
      varying vec3 vWorldPosition;
      varying vec3 vWorldNormal;
      varying vec4 vClipPosition;
      void main(){
        vec4 worldPosition = modelMatrix * vec4(position, 1.0);
        vWorldPosition = worldPosition.xyz;
        vWorldNormal = normalize(mat3(modelMatrix) * normal);
        vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
        vClipPosition = projectionMatrix * mvPosition;
        gl_Position = vClipPosition;
      }
    `,
    fragmentShader: `
      precision highp float;
      varying vec3 vWorldPosition;
      varying vec3 vWorldNormal;
      varying vec4 vClipPosition;
      uniform sampler2D uSceneTexture;
      uniform float uStrength;
      uniform float uTime;
      uniform vec3 uGlowColor;
      uniform vec3 uHighlightColor;
      void main(){
        vec3 normal = normalize(vWorldNormal);
        vec3 viewDir = normalize(cameraPosition - vWorldPosition);
        float viewDot = max(dot(normal, viewDir), 0.0);
        float fresnel = pow(1.0 - viewDot, 2.8);

        vec2 ndc = vClipPosition.xy / vClipPosition.w;
        vec2 uv = ndc * 0.5 + 0.5;
        float distortion = uStrength * (1.0 - pow(viewDot, 1.2));
        vec2 offsetDir = normal.xy;
        float offsetLen = max(length(offsetDir), 0.0001);
        vec2 offset = offsetDir / offsetLen * distortion;
        vec2 sampleUv = clamp(uv + offset, vec2(0.001), vec2(0.999));
        vec3 sceneColor = texture(uSceneTexture, sampleUv).rgb;

        float caustic = sin(uTime * 1.4 + normal.y * 6.0 + normal.x * 3.5) * 0.25 + 0.25;
        vec3 glow = uGlowColor * (0.35 + fresnel * 1.6);
        vec3 highlight = uHighlightColor * (0.2 + caustic * 0.6);
        vec3 color = sceneColor * (0.9 + fresnel * 0.2) + glow * fresnel + highlight * (1.0 - abs(normal.z));
        float alpha = 0.72 + fresnel * 0.25;
        gl_FragColor = vec4(color, alpha);
      }
    `,
    transparent: true
  });

  const orb = new THREE.Mesh(orbGeometry, orbMaterial);
  scene.add(orb);

  const curve = new THREE.CatmullRomCurve3([
    new THREE.Vector3(-0.9, -0.3, -2.6),
    new THREE.Vector3(-0.6, 0.9, -1.4),
    new THREE.Vector3(0.5, 1.3, 0.2),
    new THREE.Vector3(-0.2, 0.1, 1.8),
    new THREE.Vector3(0.7, -0.9, 2.7)
  ], false, 'centripetal', 0.6);
  const ribbon = new THREE.Mesh(
    new THREE.TubeGeometry(curve, 460, 0.1, 32, false),
    new THREE.MeshStandardMaterial({
      color: 0x13ffe6,
      emissive: 0x048cff,
      emissiveIntensity: 2.0,
      metalness: 0.28,
      roughness: 0.18,
      transparent: true,
      opacity: 0.78
    })
  );
  ribbon.rotation.y = Math.PI / 3;
  scene.add(ribbon);

  const neonTubeGroup = new THREE.Group();
  const neonMaterials = [];
  const neonPaths = [
    [
      new THREE.Vector3(-1.6, -1.1, -2.8),
      new THREE.Vector3(-1.1, 0.2, -1.4),
      new THREE.Vector3(-0.4, 0.8, 0.6),
      new THREE.Vector3(0.6, 0.4, 2.1)
    ],
    [
      new THREE.Vector3(1.4, -0.7, -2.4),
      new THREE.Vector3(0.8, 1.1, -0.9),
      new THREE.Vector3(-0.2, 1.4, 0.9),
      new THREE.Vector3(-0.9, 0.2, 2.4)
    ],
    [
      new THREE.Vector3(-0.2, -1.4, -2.2),
      new THREE.Vector3(0.1, -0.2, -0.9),
      new THREE.Vector3(0.5, 0.6, 0.3),
      new THREE.Vector3(0.2, -0.4, 1.9)
    ]
  ];
  const neonColors = [0x0dffe6, 0x13b9ff, 0x19ffd1];
  neonPaths.forEach((points, idx) => {
    const curve3 = new THREE.CatmullRomCurve3(points, false, 'centripetal', 0.7);
    const geometry = new THREE.TubeGeometry(curve3, 300, 0.05 + idx * 0.01, 24, false);
    const color = neonColors[idx % neonColors.length];
    const material = new THREE.MeshStandardMaterial({
      color,
      emissive: color,
      emissiveIntensity: 2.4,
      metalness: 0.15,
      roughness: 0.18,
      transparent: true,
      opacity: 0.85,
      depthWrite: false
    });
    neonMaterials.push(material);
    const mesh = new THREE.Mesh(geometry, material);
    neonTubeGroup.add(mesh);
  });
  neonTubeGroup.rotation.y = Math.PI / 5;
  scene.add(neonTubeGroup);

  const mistCount = isMobile ? 640 : 1100;
  const mistGeometry = new THREE.BufferGeometry();
  const mistPositions = new Float32Array(mistCount * 3);
  const mistVelocities = new Float32Array(mistCount);
  for (let i = 0; i < mistCount; i++) {
    const radius = 4 + Math.random() * 6;
    const angle = Math.random() * Math.PI * 2;
    const idx3 = i * 3;
    mistPositions[idx3] = Math.cos(angle) * radius;
    mistPositions[idx3 + 1] = -0.6 + Math.random() * 3.6;
    mistPositions[idx3 + 2] = -7 - Math.random() * 4;
    mistVelocities[i] = 0.2 + Math.random() * 0.45;
  }
  const mistAttribute = new THREE.BufferAttribute(mistPositions, 3);
  mistGeometry.setAttribute('position', mistAttribute);
  const mistTexture = new THREE.TextureLoader().load('https://cdn.jsdelivr.net/gh/mrdoob/three.js@r161/examples/textures/sprites/smoke.png');
  mistTexture.colorSpace = THREE.SRGBColorSpace;
  const mistMaterial = new THREE.PointsMaterial({
    color: 0x6ef0ff,
    size: 1.4,
    sizeAttenuation: true,
    map: mistTexture,
    transparent: true,
    opacity: 0.22,
    depthWrite: false,
    blending: THREE.AdditiveBlending
  });
  const mistField = new THREE.Points(mistGeometry, mistMaterial);
  mistField.position.y = -0.4;
  scene.add(mistField);

  const neonGridMaterial = new THREE.ShaderMaterial({
    uniforms: {
      uTime: { value: 0 },
      uColorA: { value: new THREE.Color(0x0b8cff) },
      uColorB: { value: new THREE.Color(0x09ffd8) },
      uColorC: { value: new THREE.Color(0x2a9dff) }
    },
    vertexShader: `
      varying vec2 vUv;
      uniform float uTime;
      void main(){
        vUv = uv;
        vec3 pos = position;
        float waveX = sin((pos.x + uTime * 2.4) * 0.7);
        float waveY = cos((pos.y - uTime * 1.6) * 0.9);
        float ripple = sin((pos.x + pos.y) * 0.8 - uTime * 1.8);
        pos.z += waveX * 0.45 + waveY * 0.35;
        pos.z += ripple * 0.22;
        pos.y += sin(uTime * 0.8 + pos.x * 0.4) * 0.05;
        gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
      }
    `,
    fragmentShader: `
      varying vec2 vUv;
      uniform float uTime;
      uniform vec3 uColorA;
      uniform vec3 uColorB;
      uniform vec3 uColorC;
      void main(){
        vec2 grid = fract(vUv * 12.0);
        float line = min(min(grid.x, 1.0 - grid.x), min(grid.y, 1.0 - grid.y));
        float glow = smoothstep(0.08, 0.0, line);
        float pulse = sin(uTime * 2.0 + vUv.x * 10.0) * 0.5 + 0.5;
        vec3 color = mix(uColorA, uColorB, pulse);
        color = mix(color, uColorC, sin(uTime + vUv.y * 8.0) * 0.5 + 0.5);
        gl_FragColor = vec4(color * (0.4 + glow * 1.6), glow * 0.85);
      }
    `,
    transparent: true,
    depthWrite: false,
    blending: THREE.AdditiveBlending
  });
  const neonGrid = new THREE.Mesh(new THREE.PlaneGeometry(28, 28, 140, 140), neonGridMaterial);
  neonGrid.rotation.x = -Math.PI / 2;
  neonGrid.position.set(0, -2.6, 0);
  scene.add(neonGrid);
  const neonGridMaterial2 = neonGridMaterial.clone();
  neonGridMaterial2.uniforms = THREE.UniformsUtils.clone(neonGridMaterial.uniforms);
  const neonGrid2 = new THREE.Mesh(new THREE.PlaneGeometry(24, 24, 120, 120), neonGridMaterial2);
  neonGrid2.rotation.x = -Math.PI / 2;
  neonGrid2.rotation.z = Math.PI / 6;
  neonGrid2.position.set(0, -3.4, -5.5);
  scene.add(neonGrid2);

  const clock = new THREE.Clock();
  let elapsedTime = 0;
  let isPaused = false;
  const lensVector = new THREE.Vector3();
  const portalFocus = new THREE.Vector3(0, -0.05, 0);

  function onResize(){
    const w = window.innerWidth;
    const h = window.innerHeight;
    const ratio = resolutionSelect.value === 'auto' ? pixelRatioLimits.auto() : parseFloat(resolutionSelect.value);
    renderer.setPixelRatio(ratio);
    renderer.setSize(w, h, false);
    camera.aspect = w / h;
    camera.updateProjectionMatrix();
    backgroundTarget.setSize(w * ratio, h * ratio);
  }
  window.addEventListener('resize', onResize);

  function animate(){
    const frameDelta = clock.getDelta();
    const delta = isPaused ? 0 : frameDelta;
    if (!isPaused) {
      elapsedTime += delta;
    }
    const t = elapsedTime;
    portalMaterial.uniforms.uTime.value = t;
    orbMaterial.uniforms.uTime.value = t;
    neonGridMaterial.uniforms.uTime.value = t * 0.8;
    neonGridMaterial2.uniforms.uTime.value = t * 0.65 + 1.3;

    torus.rotation.x = t * 0.34;
    torus.rotation.z = t * 0.18;
    torus.position.y = Math.sin(t * 0.6) * 0.22;
    torus.material.emissiveIntensity = 1.35 + Math.sin(t * 1.7) * 0.35;

    orb.position.set(Math.sin(t * 1.1) * 1.35, Math.cos(t * 0.8) * 0.6, Math.cos(t * 1.2) * 1.3);
    orb.rotation.y = t * 0.5;
    orb.rotation.x = Math.sin(t * 0.6) * 0.3;

    ribbon.rotation.y = Math.PI / 3 + Math.sin(t * 0.35) * 0.32;
    ribbon.rotation.x = Math.sin(t * 0.26) * 0.18;
    ribbon.material.emissiveIntensity = 1.8 + Math.sin(t * 2.1) * 0.4;

    neonTubeGroup.rotation.y = Math.PI / 5 + Math.sin(t * 0.2) * 0.35;
    neonTubeGroup.rotation.x = Math.sin(t * 0.1) * 0.08;
    neonMaterials.forEach((material, idx) => {
      material.emissiveIntensity = 2.2 + Math.sin(t * 1.5 + idx) * 0.6;
      const opacityPulse = 0.78 + Math.sin(t * 1.1 + idx) * 0.08;
      material.opacity = THREE.MathUtils.clamp(opacityPulse, 0.6, 0.95);
    });

    glimmerField.rotation.y = t * 0.04;
    glimmerField.rotation.x = Math.sin(t * 0.05) * 0.08;

    searchlightGroup.rotation.y = Math.sin(t * 0.18) * 0.4;
    searchlightRigs.forEach((entry) => {
      entry.rig.rotation.y += delta * 0.35;
      entry.rig.rotation.x = Math.sin(t * 0.42 + entry.phase) * 0.22;
      entry.spotlight.intensity = 2.6 + Math.sin(t * 1.5 + entry.phase) * 0.9;
      entry.beam.material.opacity = 0.17 + Math.sin(t * 1.2 + entry.phase) * 0.1;
      entry.target.position.x = Math.sin(t * 0.6 + entry.phase) * 0.7;
      entry.target.position.y = -1.5 + Math.cos(t * 0.7 + entry.phase) * 0.35;
    });

    keyLight.intensity = 2.2 + Math.sin(t * 1.9) * 0.5;
    rimLight.intensity = 1.5 + Math.cos(t * 1.6) * 0.45;
    hemisphere.intensity = 0.6 + Math.sin(t * 0.9) * 0.08;

    for (let i = 0; i < mistCount; i++) {
      const idx3 = i * 3;
      mistPositions[idx3 + 2] += mistVelocities[i] * delta;
      mistPositions[idx3] += Math.sin(t * 0.5 + mistPositions[idx3 + 2] * 0.3) * delta * 0.6;
      mistPositions[idx3 + 1] += Math.cos(t * 0.4 + mistPositions[idx3]) * delta * 0.3;
      if (mistPositions[idx3 + 2] > 5) {
        const radius = 4 + Math.random() * 6;
        const angle = Math.random() * Math.PI * 2;
        mistPositions[idx3] = Math.cos(angle) * radius;
        mistPositions[idx3 + 1] = -0.6 + Math.random() * 3.6;
        mistPositions[idx3 + 2] = -7 - Math.random() * 4;
        mistVelocities[i] = 0.2 + Math.random() * 0.45;
      }
    }
    if (delta > 0) {
      mistAttribute.needsUpdate = true;
    }

    const camRadius = 0.9 + Math.sin(t * 0.15) * 0.1;
    camera.position.x = Math.sin(t * 0.23) * camRadius;
    camera.position.y = 0.4 + Math.sin(t * 0.32) * 0.24;
    camera.position.z = 5.3 + Math.cos(t * 0.17) * 0.45;
    camera.lookAt(0, -0.05, 0);

    if (heading) {
      lensVector.copy(orb.position).project(camera);
      if (lensVector.z < 1.0) {
        const lensX = (lensVector.x * 0.5 + 0.5) * 100;
        const lensY = (-lensVector.y * 0.5 + 0.5) * 100;
        const strength = THREE.MathUtils.clamp(1 - orb.position.distanceTo(portalFocus) / 3.2, 0, 1);
        heading.style.setProperty('--lens-x', `${lensX.toFixed(2)}%`);
        heading.style.setProperty('--lens-y', `${lensY.toFixed(2)}%`);
        heading.style.setProperty('--lens-strength', strength.toFixed(3));
      } else {
        heading.style.setProperty('--lens-strength', '0');
      }
    }

    orb.visible = false;
    renderer.setRenderTarget(backgroundTarget);
    renderer.render(scene, camera);
    renderer.setRenderTarget(null);
    orb.visible = true;

    renderer.render(scene, camera);
    requestAnimationFrame(animate);
  }

  resolutionSelect.addEventListener('change', () => {
    applyResolution(resolutionSelect.value);
  });
  applyResolution(resolutionSelect.value);

  fullscreenToggle.addEventListener('click', () => {
    if (!document.fullscreenElement) {
      document.documentElement.requestFullscreen().then(() => {
        fullscreenToggle.textContent = 'Exit fullscreen';
      }).catch(() => {});
    } else {
      document.exitFullscreen().catch(() => {}).finally(() => {
        fullscreenToggle.textContent = 'Enter fullscreen';
      });
    }
  });

  document.addEventListener('fullscreenchange', () => {
    fullscreenToggle.textContent = document.fullscreenElement ? 'Exit fullscreen' : 'Enter fullscreen';
  });

  let gyroBaseline = null;
  let gyroActive = false;
  let lastOrientationEvent = 0;
  function updateStatus(message){
    statusLine.textContent = message;
  }
  function onOrientation(event){
    gyroActive = true;
    lastOrientationEvent = performance.now();
    if (!gyroBaseline) {
      gyroBaseline = { alpha: event.alpha, beta: event.beta, gamma: event.gamma };
      updateStatus('Gyroscope calibrated');
    }
  }
  let orientationListenerAttached = false;
  gyroButton.addEventListener('click', async () => {
    function attachListener(){
      if (!orientationListenerAttached) {
        window.addEventListener('deviceorientation', onOrientation, { passive: true });
        orientationListenerAttached = true;
      }
      gyroBaseline = null;
      updateStatus('Calibrating… move device gently');
    }
    if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {
      try {
        const permission = await DeviceOrientationEvent.requestPermission();
        if (permission === 'granted') {
          attachListener();
        } else {
          updateStatus('Gyroscope permission denied');
        }
      } catch (err) {
        updateStatus('Gyroscope unavailable');
      }
    } else if ('DeviceOrientationEvent' in window) {
      attachListener();
    } else {
      updateStatus('Gyroscope not supported');
    }
  });

  document.addEventListener('keydown', (event) => {
    if (event.code === 'Space') {
      event.preventDefault();
      isPaused = !isPaused;
      updateStatus(isPaused ? 'Motion paused' : 'Motion resumed');
    }
  });

  setInterval(() => {
    if (gyroActive && performance.now() - lastOrientationEvent > 5000) {
      gyroActive = false;
      updateStatus('Gyroscope idle');
    }
  }, 4000);

  animate();
});
</script>
</body>
</html>
