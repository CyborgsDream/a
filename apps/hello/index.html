<!--
@project: a/hello — sample mini-app
@version: v1.1.0
@date: 2025-11-07 (Europe/Warsaw)
@blurb: Hello goes interstellar with a neon portal rendered in realtime 3D via THREE.js.
-->
<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1">
<title>a/hello</title>
<script type="importmap">{
  "imports": { "@shared/": "../../shared/v1/" }
}</script>
<style>
  :root{
    color-scheme: dark;
    font-family: "Space Grotesk", "Segoe UI", system-ui, sans-serif;
  }
  body{
    margin:0;
    min-height:100dvh;
    background:radial-gradient(circle at 50% 20%,rgba(38,15,75,.8),rgba(6,2,20,.95) 45%,rgba(2,0,10,1));
    color:#f8f3ff;
    overflow:hidden;
  }
  #scene{
    position:fixed;
    inset:0;
    z-index:0;
  }
  #scene canvas{display:block;width:100%;height:100%;}
  #hud{
    position:relative;
    z-index:1;
    display:grid;
    place-items:center;
    text-align:center;
    padding:4rem clamp(2rem,4vw,5rem);
    height:100dvh;
    pointer-events:none;
  }
  #hud::before{
    content:"";
    position:absolute;
    inset:20% 25%;
    border-radius:32px;
    background:linear-gradient(135deg,rgba(255,70,235,.18),rgba(31,195,255,.05));
    filter:blur(60px);
    z-index:-1;
  }
  h1{
    margin:0 0 .5rem;
    font-size:clamp(2.8rem,7vw,5.4rem);
    letter-spacing:.06em;
    text-transform:uppercase;
    text-shadow:0 0 35px rgba(124,255,255,.85);
  }
  p{
    margin:0;
    max-width:28rem;
    line-height:1.6;
    font-size:clamp(1.05rem,2.2vw,1.35rem);
    color:rgba(228,238,255,.85);
  }
</style>
</head>
<body>
<div id="scene"></div>
<div id="hud">
  <div>
    <h1>Hello, cosmos</h1>
    <p>Ride a shimmering ribbon into a living portal—an iridescent greeting sculpted with THREE.js.</p>
  </div>
</div>
<script type="module">
import { $$ } from '@shared/utils.js';
import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.161.0/build/three.module.js';

$$.onReady(() => {
  const container = document.getElementById('scene');
  const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
  renderer.setPixelRatio(window.devicePixelRatio);
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.outputColorSpace = THREE.SRGBColorSpace;
  container.appendChild(renderer.domElement);

  const scene = new THREE.Scene();
  scene.fog = new THREE.FogExp2(0x050318, 0.16);

  const camera = new THREE.PerspectiveCamera(52, window.innerWidth / window.innerHeight, 0.1, 200);
  camera.position.set(0, 0.6, 5.4);

  const ambient = new THREE.AmbientLight(0x5660aa, 0.65);
  const keyLight = new THREE.PointLight(0x7e5dff, 2.4, 25, 2);
  keyLight.position.set(4.4, 5, 3.2);
  const rimLight = new THREE.PointLight(0x28e4ff, 1.8, 20, 2);
  rimLight.position.set(-3.6, -1.2, -2.4);
  scene.add(ambient, keyLight, rimLight);

  const starCount = 1600;
  const starGeometry = new THREE.BufferGeometry();
  const starPositions = new Float32Array(starCount * 3);
  for (let i = 0; i < starCount; i++) {
    const radius = 12 + Math.random() * 22;
    const theta = Math.random() * Math.PI * 2;
    const phi = Math.acos(2 * Math.random() - 1);
    starPositions[i * 3] = radius * Math.sin(phi) * Math.cos(theta);
    starPositions[i * 3 + 1] = radius * Math.cos(phi);
    starPositions[i * 3 + 2] = radius * Math.sin(phi) * Math.sin(theta);
  }
  starGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starPositions, 3));
  const starMaterial = new THREE.PointsMaterial({
    color: 0x9ef9ff,
    size: 0.05,
    sizeAttenuation: true,
    transparent: true,
    opacity: 0.9,
    depthWrite: false
  });
  const starField = new THREE.Points(starGeometry, starMaterial);
  scene.add(starField);

  const backdrop = new THREE.Mesh(
    new THREE.SphereGeometry(55, 48, 48),
    new THREE.MeshBasicMaterial({ color: 0x03020a, side: THREE.BackSide, fog: false })
  );
  scene.add(backdrop);

  const portalMaterial = new THREE.ShaderMaterial({
    uniforms: {
      uTime: { value: 0 },
      uColor1: { value: new THREE.Color(0x7a3cff) },
      uColor2: { value: new THREE.Color(0x00fff7) }
    },
    vertexShader: `
      varying vec2 vUv;
      uniform float uTime;
      void main(){
        vUv = uv;
        vec3 displaced = position + normal * (0.22 * sin((uv.x + uv.y + uTime) * 6.0));
        gl_Position = projectionMatrix * modelViewMatrix * vec4(displaced, 1.0);
      }
    `,
    fragmentShader: `
      varying vec2 vUv;
      uniform float uTime;
      uniform vec3 uColor1;
      uniform vec3 uColor2;
      void main(){
        float wave = sin((vUv.x * 2.5 + vUv.y * 2.5 + uTime * 1.2) * 3.2);
        float radial = smoothstep(1.0, 0.25, length(vUv - 0.5));
        vec3 color = mix(uColor1, uColor2, clamp(vUv.y + wave * 0.08, 0.0, 1.0));
        color += radial * 0.55;
        gl_FragColor = vec4(color, radial);
      }
    `,
    transparent: true,
    side: THREE.DoubleSide
  });
  const portal = new THREE.Mesh(new THREE.RingGeometry(1.4, 2.4, 128, 48), portalMaterial);
  portal.rotation.x = Math.PI / 2;
  scene.add(portal);

  const torus = new THREE.Mesh(
    new THREE.TorusKnotGeometry(1, 0.32, 320, 48, 2, 5),
    new THREE.MeshStandardMaterial({
      color: 0xff6bd9,
      metalness: 0.55,
      roughness: 0.18,
      emissive: 0x511764,
      emissiveIntensity: 1.3
    })
  );
  scene.add(torus);

  const orb = new THREE.Mesh(
    new THREE.IcosahedronGeometry(0.82, 3),
    new THREE.MeshPhysicalMaterial({
      color: 0x74fff8,
      metalness: 0.1,
      roughness: 0.08,
      emissive: 0x0099ff,
      emissiveIntensity: 1.5,
      transmission: 0.85,
      thickness: 1.4,
      clearcoat: 1,
      clearcoatRoughness: 0.05
    })
  );
  scene.add(orb);

  const curve = new THREE.CatmullRomCurve3([
    new THREE.Vector3(0, 0.2, -2.5),
    new THREE.Vector3(0.6, 0.9, -1.2),
    new THREE.Vector3(-0.6, 1.2, 0.2),
    new THREE.Vector3(0.8, 0.2, 1.6),
    new THREE.Vector3(-0.4, -0.8, 2.6)
  ], false, 'catmullrom', 0.4);
  const ribbon = new THREE.Mesh(
    new THREE.TubeGeometry(curve, 420, 0.12, 32, false),
    new THREE.MeshStandardMaterial({
      color: 0x8df3ff,
      emissive: 0x1c92ff,
      emissiveIntensity: 1.4,
      metalness: 0.35,
      roughness: 0.22
    })
  );
  ribbon.rotation.y = Math.PI / 3;
  scene.add(ribbon);

  const clock = new THREE.Clock();

  function onResize(){
    const w = window.innerWidth;
    const h = window.innerHeight;
    renderer.setSize(w, h);
    camera.aspect = w / h;
    camera.updateProjectionMatrix();
  }
  window.addEventListener('resize', onResize);

  function animate(){
    const t = clock.getElapsedTime();
    portalMaterial.uniforms.uTime.value = t;

    torus.rotation.x = t * 0.42;
    torus.rotation.y = t * 0.24;
    torus.position.y = Math.sin(t * 0.8) * 0.18;

    orb.position.set(Math.sin(t * 1.4) * 1.5, Math.cos(t * 1.1) * 0.6, Math.cos(t * 1.3) * 1.5);
    orb.rotation.y = t * 0.6;

    ribbon.rotation.y = Math.PI / 3 + Math.sin(t * 0.4) * 0.25;
    ribbon.rotation.x = Math.sin(t * 0.3) * 0.15;

    starField.rotation.y = t * 0.06;
    starField.rotation.x = Math.sin(t * 0.05) * 0.08;

    keyLight.intensity = 2.4 + Math.sin(t * 2.1) * 0.45;
    rimLight.intensity = 1.8 + Math.cos(t * 1.7) * 0.3;

    const camRadius = 0.85;
    camera.position.x = Math.sin(t * 0.28) * camRadius;
    camera.position.y = 0.55 + Math.sin(t * 0.42) * 0.18;
    camera.position.z = 5.1 + Math.cos(t * 0.2) * 0.4;
    camera.lookAt(0, 0.1, 0);

    renderer.render(scene, camera);
    requestAnimationFrame(animate);
  }

  animate();
});
</script>
</body>
</html>
