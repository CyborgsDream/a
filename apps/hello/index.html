<!--
@project: a/hello — sample mini-app
@version: v1.1.0
@date: 2025-11-07 (Europe/Warsaw)
@blurb: Hello goes interstellar with a neon portal rendered in realtime 3D via THREE.js.
-->
<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1">
<title>a/hello</title>
<script type="importmap">{
  "imports": { "@shared/": "../../shared/v1/" }
}</script>
<style>
  :root{
    color-scheme: dark;
    font-family: "Space Grotesk", "Segoe UI", system-ui, sans-serif;
  }
  body{
    margin:0;
    min-height:100dvh;
    background:radial-gradient(circle at 50% 20%,rgba(38,15,75,.8),rgba(6,2,20,.95) 45%,rgba(2,0,10,1));
    color:#f8f3ff;
    overflow:hidden;
  }
  #scene{
    position:fixed;
    inset:0;
    z-index:0;
  }
  #scene canvas{display:block;width:100%;height:100%;}
  #hud{
    position:relative;
    z-index:1;
    display:grid;
    place-items:center;
    text-align:center;
    padding:4rem clamp(2rem,4vw,5rem);
    height:100dvh;
    pointer-events:none;
  }
  #hud::before{
    content:"";
    position:absolute;
    inset:20% 25%;
    border-radius:32px;
    background:linear-gradient(135deg,rgba(255,70,235,.18),rgba(31,195,255,.05));
    filter:blur(60px);
    z-index:-1;
  }
  h1{
    margin:0 0 .5rem;
    font-size:clamp(2.8rem,7vw,5.4rem);
    letter-spacing:.06em;
    text-transform:uppercase;
    text-shadow:0 0 35px rgba(124,255,255,.85);
    position:relative;
    display:inline-block;
    --lens-x:50%;
    --lens-y:50%;
    --lens-strength:0;
  }
  h1::after{
    content:"";
    position:absolute;
    inset:-18%;
    border-radius:50%;
    background:radial-gradient(circle at var(--lens-x) var(--lens-y),rgba(180,255,255,.75),rgba(56,245,255,.45) 28%,rgba(18,220,255,.05) 58%,rgba(0,0,0,0) 80%);
    filter:blur(10px) saturate(1.4);
    mix-blend-mode:screen;
    opacity:calc(var(--lens-strength) * .85);
    transition:opacity .22s ease;
    pointer-events:none;
  }
  p{
    margin:0;
    max-width:28rem;
    line-height:1.6;
    font-size:clamp(1.05rem,2.2vw,1.35rem);
    color:rgba(228,238,255,.85);
  }
</style>
</head>
<body>
<div id="scene"></div>
<div id="hud">
  <div>
    <h1>Hello, cosmos</h1>
    <p>Ride a shimmering ribbon into a living portal—an iridescent greeting sculpted with THREE.js.</p>
  </div>
</div>
<script type="module">
import { $$ } from '@shared/utils.js';
import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.161.0/build/three.module.js';

$$.onReady(() => {
  const container = document.getElementById('scene');
  const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
  renderer.setPixelRatio(window.devicePixelRatio);
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.outputColorSpace = THREE.SRGBColorSpace;
  container.appendChild(renderer.domElement);

  const scene = new THREE.Scene();
  scene.fog = new THREE.FogExp2(0x050318, 0.16);

  const camera = new THREE.PerspectiveCamera(52, window.innerWidth / window.innerHeight, 0.1, 200);
  camera.position.set(0, 0.6, 5.4);

  const heading = document.querySelector('#hud h1');

  const ambient = new THREE.AmbientLight(0x5660aa, 0.65);
  const keyLight = new THREE.PointLight(0x7e5dff, 2.4, 25, 2);
  keyLight.position.set(4.4, 5, 3.2);
  const rimLight = new THREE.PointLight(0x28e4ff, 1.8, 20, 2);
  rimLight.position.set(-3.6, -1.2, -2.4);
  scene.add(ambient, keyLight, rimLight);

  const starCount = 1600;
  const starGeometry = new THREE.BufferGeometry();
  const starPositions = new Float32Array(starCount * 3);
  for (let i = 0; i < starCount; i++) {
    const radius = 12 + Math.random() * 22;
    const theta = Math.random() * Math.PI * 2;
    const phi = Math.acos(2 * Math.random() - 1);
    starPositions[i * 3] = radius * Math.sin(phi) * Math.cos(theta);
    starPositions[i * 3 + 1] = radius * Math.cos(phi);
    starPositions[i * 3 + 2] = radius * Math.sin(phi) * Math.sin(theta);
  }
  starGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starPositions, 3));
  const starMaterial = new THREE.PointsMaterial({
    color: 0x9ef9ff,
    size: 0.05,
    sizeAttenuation: true,
    transparent: true,
    opacity: 0.9,
    depthWrite: false
  });
  const starField = new THREE.Points(starGeometry, starMaterial);
  scene.add(starField);

  const backdrop = new THREE.Mesh(
    new THREE.SphereGeometry(55, 48, 48),
    new THREE.MeshBasicMaterial({ color: 0x03020a, side: THREE.BackSide, fog: false })
  );
  scene.add(backdrop);

  const backgroundTarget = new THREE.WebGLRenderTarget(
    window.innerWidth * renderer.getPixelRatio(),
    window.innerHeight * renderer.getPixelRatio(),
    { depthBuffer: false }
  );
  backgroundTarget.texture.colorSpace = THREE.SRGBColorSpace;

  const portalMaterial = new THREE.ShaderMaterial({
    uniforms: {
      uTime: { value: 0 },
      uColor1: { value: new THREE.Color(0x7a3cff) },
      uColor2: { value: new THREE.Color(0x00fff7) }
    },
    vertexShader: `
      varying vec2 vUv;
      uniform float uTime;
      void main(){
        vUv = uv;
        vec3 displaced = position + normal * (0.22 * sin((uv.x + uv.y + uTime) * 6.0));
        gl_Position = projectionMatrix * modelViewMatrix * vec4(displaced, 1.0);
      }
    `,
    fragmentShader: `
      varying vec2 vUv;
      uniform float uTime;
      uniform vec3 uColor1;
      uniform vec3 uColor2;
      void main(){
        float wave = sin((vUv.x * 2.5 + vUv.y * 2.5 + uTime * 1.2) * 3.2);
        float radial = smoothstep(1.0, 0.25, length(vUv - 0.5));
        vec3 color = mix(uColor1, uColor2, clamp(vUv.y + wave * 0.08, 0.0, 1.0));
        color += radial * 0.55;
        gl_FragColor = vec4(color, radial);
      }
    `,
    transparent: true,
    side: THREE.DoubleSide
  });
  const portal = new THREE.Mesh(new THREE.RingGeometry(1.4, 2.4, 128, 48), portalMaterial);
  portal.rotation.x = Math.PI / 2;
  scene.add(portal);

  const torus = new THREE.Mesh(
    new THREE.TorusKnotGeometry(1, 0.32, 320, 48, 2, 5),
    new THREE.MeshStandardMaterial({
      color: 0xff6bd9,
      metalness: 0.55,
      roughness: 0.18,
      emissive: 0x511764,
      emissiveIntensity: 1.3
    })
  );
  scene.add(torus);

  const orbGeometry = new THREE.IcosahedronGeometry(0.82, 4);
  const orbMaterial = new THREE.ShaderMaterial({
    uniforms: {
      uSceneTexture: { value: backgroundTarget.texture },
      uStrength: { value: 0.18 },
      uTime: { value: 0 },
      uGlowColor: { value: new THREE.Color(0x74fff8) },
      uHighlightColor: { value: new THREE.Color(0x00baff) }
    },
    vertexShader: `
      varying vec3 vWorldPosition;
      varying vec3 vWorldNormal;
      varying vec4 vClipPosition;
      void main(){
        vec4 worldPosition = modelMatrix * vec4(position, 1.0);
        vWorldPosition = worldPosition.xyz;
        vWorldNormal = normalize(mat3(modelMatrix) * normal);
        vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
        vClipPosition = projectionMatrix * mvPosition;
        gl_Position = vClipPosition;
      }
    `,
    fragmentShader: `
      precision highp float;
      varying vec3 vWorldPosition;
      varying vec3 vWorldNormal;
      varying vec4 vClipPosition;
      uniform sampler2D uSceneTexture;
      uniform float uStrength;
      uniform float uTime;
      uniform vec3 uGlowColor;
      uniform vec3 uHighlightColor;
      void main(){
        vec3 normal = normalize(vWorldNormal);
        vec3 viewDir = normalize(cameraPosition - vWorldPosition);
        float viewDot = max(dot(normal, viewDir), 0.0);
        float fresnel = pow(1.0 - viewDot, 2.8);

        vec2 ndc = vClipPosition.xy / vClipPosition.w;
        vec2 uv = ndc * 0.5 + 0.5;
        float distortion = uStrength * (1.0 - pow(viewDot, 1.2));
        vec2 offsetDir = normal.xy;
        float offsetLen = max(length(offsetDir), 0.0001);
        vec2 offset = offsetDir / offsetLen * distortion;
        vec2 sampleUv = clamp(uv + offset, vec2(0.001), vec2(0.999));
        vec3 sceneColor = texture(uSceneTexture, sampleUv).rgb;

        float caustic = sin(uTime * 1.4 + normal.y * 6.0 + normal.x * 3.5) * 0.25 + 0.25;
        vec3 glow = uGlowColor * (0.35 + fresnel * 1.6);
        vec3 highlight = uHighlightColor * (0.2 + caustic * 0.6);
        vec3 color = sceneColor * (0.9 + fresnel * 0.2) + glow * fresnel + highlight * (1.0 - abs(normal.z));
        float alpha = 0.72 + fresnel * 0.25;
        gl_FragColor = vec4(color, alpha);
      }
    `,
    transparent: true
  });

  const orb = new THREE.Mesh(orbGeometry, orbMaterial);
  scene.add(orb);

  const curve = new THREE.CatmullRomCurve3([
    new THREE.Vector3(0, 0.2, -2.5),
    new THREE.Vector3(0.6, 0.9, -1.2),
    new THREE.Vector3(-0.6, 1.2, 0.2),
    new THREE.Vector3(0.8, 0.2, 1.6),
    new THREE.Vector3(-0.4, -0.8, 2.6)
  ], false, 'catmullrom', 0.4);
  const ribbon = new THREE.Mesh(
    new THREE.TubeGeometry(curve, 420, 0.12, 32, false),
    new THREE.MeshStandardMaterial({
      color: 0x8df3ff,
      emissive: 0x1c92ff,
      emissiveIntensity: 1.4,
      metalness: 0.35,
      roughness: 0.22
    })
  );
  ribbon.rotation.y = Math.PI / 3;
  scene.add(ribbon);

  const clock = new THREE.Clock();
  const lensVector = new THREE.Vector3();
  const portalFocus = new THREE.Vector3(0, 0.1, 0);

  function onResize(){
    const w = window.innerWidth;
    const h = window.innerHeight;
    const dpr = window.devicePixelRatio;
    renderer.setPixelRatio(dpr);
    renderer.setSize(w, h);
    camera.aspect = w / h;
    camera.updateProjectionMatrix();
    backgroundTarget.setSize(w * dpr, h * dpr);
  }
  window.addEventListener('resize', onResize);

  function animate(){
    const t = clock.getElapsedTime();
    portalMaterial.uniforms.uTime.value = t;
    orbMaterial.uniforms.uTime.value = t;

    torus.rotation.x = t * 0.42;
    torus.rotation.y = t * 0.24;
    torus.position.y = Math.sin(t * 0.8) * 0.18;

    orb.position.set(Math.sin(t * 1.4) * 1.5, Math.cos(t * 1.1) * 0.6, Math.cos(t * 1.3) * 1.5);
    orb.rotation.y = t * 0.6;

    if (heading) {
      lensVector.copy(orb.position).project(camera);
      if (lensVector.z < 1.0) {
        const lensX = (lensVector.x * 0.5 + 0.5) * 100;
        const lensY = (-lensVector.y * 0.5 + 0.5) * 100;
        const strength = THREE.MathUtils.clamp(1 - orb.position.distanceTo(portalFocus) / 3.4, 0, 1);
        heading.style.setProperty('--lens-x', `${lensX.toFixed(2)}%`);
        heading.style.setProperty('--lens-y', `${lensY.toFixed(2)}%`);
        heading.style.setProperty('--lens-strength', strength.toFixed(3));
      } else {
        heading.style.setProperty('--lens-strength', '0');
      }
    }

    ribbon.rotation.y = Math.PI / 3 + Math.sin(t * 0.4) * 0.25;
    ribbon.rotation.x = Math.sin(t * 0.3) * 0.15;

    starField.rotation.y = t * 0.06;
    starField.rotation.x = Math.sin(t * 0.05) * 0.08;

    keyLight.intensity = 2.4 + Math.sin(t * 2.1) * 0.45;
    rimLight.intensity = 1.8 + Math.cos(t * 1.7) * 0.3;

    const camRadius = 0.85;
    camera.position.x = Math.sin(t * 0.28) * camRadius;
    camera.position.y = 0.55 + Math.sin(t * 0.42) * 0.18;
    camera.position.z = 5.1 + Math.cos(t * 0.2) * 0.4;
    camera.lookAt(0, 0.1, 0);

    orb.visible = false;
    renderer.setRenderTarget(backgroundTarget);
    renderer.render(scene, camera);
    renderer.setRenderTarget(null);
    orb.visible = true;

    renderer.render(scene, camera);
    requestAnimationFrame(animate);
  }

  animate();
});
</script>
</body>
</html>
