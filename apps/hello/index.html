<!--
@project: a/hello — sample mini-app
@version: v1.2.0
@date: 2025-11-07 (Europe/Warsaw)
@blurb: Descend into an abyssal greeting awash in bioluminescent light and drifting mist.
-->
<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1">
<title>a/hello</title>
<script type="importmap">{
  "imports": { "@shared/": "../../shared/v1/" }
}</script>
<style>
  :root{
    color-scheme: dark;
    font-family: "Space Grotesk", "Segoe UI", system-ui, sans-serif;
  }
  body{
    margin:0;
    min-height:100dvh;
    background:radial-gradient(circle at 50% 20%,rgba(2,20,35,.9),rgba(0,9,20,.96) 48%,rgba(0,4,10,1));
    color:#dff7ff;
    overflow:hidden;
  }
  #scene{
    position:fixed;
    inset:0;
    z-index:0;
  }
  #scene canvas{display:block;width:100%;height:100%;}
  #hud{
    position:relative;
    z-index:1;
    display:grid;
    place-items:center;
    text-align:center;
    padding:4rem clamp(2rem,4vw,5rem);
    height:100dvh;
    pointer-events:none;
  }
  #hud::before{
    content:"";
    position:absolute;
    inset:18% 22%;
    border-radius:38px;
    background:linear-gradient(140deg,rgba(20,130,200,.18),rgba(0,220,200,.06));
    box-shadow:0 0 120px rgba(0,180,255,.2);
    filter:blur(70px);
    z-index:-1;
  }
  h1{
    margin:0 0 .5rem;
    font-size:clamp(2.8rem,7vw,5.4rem);
    letter-spacing:.08em;
    text-transform:uppercase;
    text-shadow:0 0 45px rgba(40,220,255,.88);
    position:relative;
    display:inline-block;
    --lens-x:50%;
    --lens-y:50%;
    --lens-strength:0;
  }
  h1::after{
    content:"";
    position:absolute;
    inset:-18%;
    border-radius:50%;
    background:radial-gradient(circle at var(--lens-x) var(--lens-y),rgba(80,190,255,.75),rgba(0,255,205,.4) 30%,rgba(0,80,140,.08) 60%,rgba(0,0,0,0) 80%);
    filter:blur(10px) saturate(1.4);
    mix-blend-mode:screen;
    opacity:calc(var(--lens-strength) * .85);
    transition:opacity .22s ease;
    pointer-events:none;
  }
  p{
    margin:0;
    max-width:28rem;
    line-height:1.6;
    font-size:clamp(1.05rem,2.2vw,1.35rem);
    color:rgba(190,232,255,.82);
  }
  #ui-overlay{
    position:fixed;
    inset:0;
    display:flex;
    flex-direction:column;
    justify-content:space-between;
    padding:1.25rem clamp(1rem,2.5vw,2.7rem);
    pointer-events:none;
    z-index:2;
    color:#e9fbff;
    font-size:.85rem;
    letter-spacing:.04em;
    gap:1.2rem;
  }
  #ui-top{
    display:flex;
    justify-content:space-between;
    align-items:flex-start;
    gap:1.25rem;
    flex-wrap:wrap;
  }
  #fps-counter{
    pointer-events:none;
    display:flex;
    align-items:center;
    gap:.5rem;
    background:linear-gradient(150deg,rgba(6,34,58,.82),rgba(4,18,32,.92));
    border:1px solid rgba(64,210,255,.38);
    padding:.45rem .95rem;
    border-radius:16px;
    box-shadow:0 0 22px rgba(0,180,255,.28);
    backdrop-filter:blur(14px);
    font-variant-numeric:tabular-nums;
    text-transform:uppercase;
    min-width:120px;
  }
  #fps-counter .label{
    font-size:.68rem;
    letter-spacing:.24em;
    color:rgba(170,235,255,.68);
  }
  #fps-counter .value{
    font-size:1.05rem;
    font-weight:600;
    letter-spacing:.12em;
    color:rgba(230,255,255,.92);
  }
  #control-panel{
    pointer-events:auto;
    display:grid;
    grid-template-columns:minmax(0,1fr);
    align-items:start;
    gap:.55rem;
    padding:.95rem 1.1rem 1.05rem;
    border-radius:18px;
    background:linear-gradient(168deg,rgba(4,28,48,.82),rgba(0,12,24,.9));
    border:1px solid rgba(32,180,255,.32);
    box-shadow:0 0 32px rgba(0,128,255,.25);
    min-width:min(320px,100%);
  }
  #control-panel label{
    display:flex;
    flex-direction:column;
    gap:.35rem;
    font-size:.78rem;
    text-transform:uppercase;
    width:100%;
  }
  #control-panel .label-text{
    letter-spacing:.18em;
    color:rgba(190,240,255,.76);
  }
  #control-panel select,
  #control-panel button{
    font:inherit;
    color:inherit;
    background:rgba(0,30,60,.65);
    border:1px solid rgba(40,210,255,.45);
    border-radius:12px;
    padding:.45rem .8rem;
    text-transform:uppercase;
    letter-spacing:.08em;
    cursor:pointer;
    transition:background .2s ease,transform .2s ease;
    width:100%;
  }
  #control-panel select:focus,
  #control-panel button:focus{
    outline:2px solid rgba(72,240,255,.75);
    outline-offset:2px;
  }
  #control-panel button:hover,
  #control-panel select:hover{
    background:rgba(0,48,90,.85);
    transform:translateY(-1px);
  }
  #control-panel .control-actions{
    display:grid;
    grid-template-columns:minmax(0,1fr);
    gap:.45rem;
    width:100%;
  }
  #legend{
    display:grid;
    gap:.35rem;
    font-size:.76rem;
    text-transform:uppercase;
    padding-top:.4rem;
    border-top:1px solid rgba(28,120,180,.28);
    margin-top:.2rem;
  }
  #legend strong{color:rgba(120,240,255,.95);font-weight:600;}
  #status-line{
    font-size:.72rem;
    color:rgba(180,240,255,.75);
    text-transform:uppercase;
    letter-spacing:.12em;
    margin-top:.1rem;
  }
  h1{
    transition:opacity .6s ease,filter .6s ease;
  }
  h1.is-ghosted{
    opacity:0;
    filter:blur(12px) saturate(1.4);
  }
  @media (min-width:820px){
    #control-panel{
      grid-template-columns:repeat(2,minmax(0,1fr));
      gap:.65rem 1.1rem;
    }
    #control-panel label,
    #legend,
    #status-line{
      grid-column:1 / -1;
    }
    #control-panel .control-actions{
      grid-template-columns:repeat(2,minmax(0,1fr));
    }
  }
  @media (max-width:768px){
    #ui-overlay{padding:1rem;gap:1rem;font-size:.78rem;}
    #ui-top{flex-direction:column;align-items:flex-start;gap:1rem;}
    #control-panel{width:100%;min-width:0;padding:.85rem .9rem;}
  }
</style>
</head>
<body>
<div id="scene"></div>
<div id="ui-overlay">
  <div id="ui-top">
    <div id="fps-counter" aria-live="polite" role="status">
      <span class="label">FPS</span>
      <span class="value">--</span>
    </div>
    <div id="control-panel" aria-live="polite">
      <label for="resolution-select">
        <span class="label-text">Resolution</span>
        <select id="resolution-select">
          <option value="auto">Auto adaptive</option>
          <option value="1.25">High (1.25×)</option>
          <option value="1">Standard (1×)</option>
          <option value="0.75">Performance (0.75×)</option>
          <option value="0.5">Ultra performance (0.5×)</option>
        </select>
      </label>
      <div class="control-actions">
        <button type="button" id="fullscreen-toggle">Enter fullscreen</button>
        <button type="button" id="gyro-calibrate">Calibrate gyroscope</button>
      </div>
      <div id="legend">
        <strong>Navigation</strong>
        <span>Space — Toggle motion</span>
        <span>Pointer — Lens focus sweep</span>
        <span>Auto-orbit camera — Cinematic glide</span>
      </div>
      <div id="status-line">Gyroscope idle</div>
    </div>
  </div>
</div>
<div id="hud">
  <div>
    <h1>Greetings from the abyss</h1>
    <p>Descend through sonar pulses and veils of vapor, guided by neon beacons that sweep the endless deep.</p>
  </div>
</div>
<script type="module">
import { $$ } from '@shared/utils.js';
import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.161.0/build/three.module.js';

$$.onReady(() => {
  const container = document.getElementById('scene');
  const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
  const mobileQuery = window.matchMedia('(max-width: 768px)');
  const uaIsMobile = /Mobi|Android|iPhone|iPad|iPod/i.test(navigator.userAgent);
  let isMobile = uaIsMobile || mobileQuery.matches;
  const resolutionSelect = document.getElementById('resolution-select');
  const fullscreenToggle = document.getElementById('fullscreen-toggle');
  const gyroButton = document.getElementById('gyro-calibrate');
  const statusLine = document.getElementById('status-line');
  const fpsCounter = document.getElementById('fps-counter');
  const fpsValue = fpsCounter ? fpsCounter.querySelector('.value') : null;
  if (fpsCounter && fpsValue) {
    fpsCounter.setAttribute('aria-label', 'Frame rate -- frames per second');
  }
  let currentResolution = resolutionSelect.value;

  const pixelRatioLimits = {
    auto(){
      const cap = isMobile ? 1.1 : 1.7;
      return Math.min(window.devicePixelRatio || 1, cap);
    },
    fixed(value){
      return value;
    }
  };

  renderer.outputColorSpace = THREE.SRGBColorSpace;
  container.appendChild(renderer.domElement);

  const scene = new THREE.Scene();
  scene.fog = new THREE.FogExp2(0x01070f, 0.22);

  const camera = new THREE.PerspectiveCamera(52, window.innerWidth / window.innerHeight, 0.1, 200);
  camera.position.set(0.35, 0.45, 5.6);

  const headingElement = document.querySelector('#hud h1');
  const headingText = headingElement ? headingElement.textContent.trim() : 'Greetings from the abyss';

  function createHeadingTexture(text){
    const scale = 2;
    const size = { width: 1024, height: 256 };
    const canvas = document.createElement('canvas');
    canvas.width = size.width * scale;
    canvas.height = size.height * scale;
    const ctx = canvas.getContext('2d');
    if (!ctx) {
      return new THREE.CanvasTexture(canvas);
    }
    ctx.setTransform(scale, 0, 0, scale, 0, 0);
    ctx.clearRect(0, 0, size.width, size.height);
    ctx.fillStyle = 'rgba(0,0,0,0)';
    ctx.fillRect(0, 0, size.width, size.height);
    ctx.save();
    ctx.translate(size.width / 2, size.height / 2);
    ctx.font = '700 128px "Space Grotesk", "Segoe UI", system-ui, sans-serif';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.shadowColor = 'rgba(32,255,220,0.55)';
    ctx.shadowBlur = 48;
    ctx.fillStyle = '#a8faff';
    ctx.fillText(text, 0, 0);
    ctx.shadowColor = 'rgba(12,148,255,0.65)';
    ctx.shadowBlur = 28;
    ctx.strokeStyle = 'rgba(12,228,255,0.35)';
    ctx.lineWidth = 3;
    ctx.strokeText(text, 0, 0);
    ctx.restore();
    ctx.globalCompositeOperation = 'lighter';
    const grad = ctx.createLinearGradient(0, 0, size.width, size.height);
    grad.addColorStop(0, 'rgba(0,170,255,0.25)');
    grad.addColorStop(0.55, 'rgba(0,255,220,0.9)');
    grad.addColorStop(1, 'rgba(40,150,255,0.3)');
    ctx.fillStyle = grad;
    ctx.globalAlpha = 0.22;
    ctx.fillRect(0, size.height * 0.2, size.width, size.height * 0.6);
    ctx.globalAlpha = 1;
    ctx.globalCompositeOperation = 'source-over';
    const texture = new THREE.CanvasTexture(canvas);
    texture.colorSpace = THREE.SRGBColorSpace;
    if (renderer.capabilities.getMaxAnisotropy) {
      texture.anisotropy = renderer.capabilities.getMaxAnisotropy();
    }
    texture.needsUpdate = true;
    return texture;
  }

  const headingTexture = createHeadingTexture(headingText);

  const backgroundTarget = new THREE.WebGLRenderTarget(
    window.innerWidth * (window.devicePixelRatio || 1),
    window.innerHeight * (window.devicePixelRatio || 1),
    { depthBuffer: false }
  );
  backgroundTarget.texture.colorSpace = THREE.SRGBColorSpace;

  const headingMaterial = new THREE.ShaderMaterial({
    uniforms: {
      uSceneTexture: { value: backgroundTarget.texture },
      uHeadingTexture: { value: headingTexture },
      uTime: { value: 0 },
      uNeonA: { value: new THREE.Color(0x16ffe3) },
      uNeonB: { value: new THREE.Color(0x1188ff) },
      uLensFactor: { value: 0.22 },
      uLensIntensity: { value: 0.6 }
    },
    vertexShader: `
      varying vec2 vUv;
      varying vec4 vClipPosition;
      void main(){
        vUv = uv;
        vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
        vClipPosition = projectionMatrix * mvPosition;
        gl_Position = vClipPosition;
      }
    `,
    fragmentShader: `
      precision highp float;
      varying vec2 vUv;
      varying vec4 vClipPosition;
      uniform sampler2D uSceneTexture;
      uniform sampler2D uHeadingTexture;
      uniform float uTime;
      uniform vec3 uNeonA;
      uniform vec3 uNeonB;
      uniform float uLensFactor;
      uniform float uLensIntensity;
      void main(){
        vec2 centered = vUv - 0.5;
        float radius = length(centered);
        vec2 ndc = vClipPosition.xy / vClipPosition.w;
        vec2 baseUv = ndc * 0.5 + 0.5;
        float swirl = sin(uTime * 1.6 + centered.y * 9.0 + centered.x * 7.0);
        float intensity = mix(0.35, 1.0, clamp(uLensIntensity, 0.0, 1.0));
        float strength = uLensFactor * intensity * (0.6 + swirl * 0.12);
        vec2 lensDir = normalize(centered + vec2(1e-4));
        vec2 sampleUv = clamp(baseUv + lensDir * radius * strength, vec2(0.001), vec2(0.999));
        vec3 refracted = texture2D(uSceneTexture, sampleUv).rgb;
        vec4 glyph = texture2D(uHeadingTexture, vUv);
        float mask = glyph.a;
        float edge = smoothstep(0.0, 0.12, mask) * (1.0 - smoothstep(0.35, 0.7, radius));
        float neonPulse = sin(uTime * 2.0 + vUv.x * 24.0) * 0.5 + 0.5;
        vec3 neon = mix(uNeonA, uNeonB, neonPulse);
        vec3 baseColor = mix(refracted, glyph.rgb, clamp(mask * 0.9, 0.0, 1.0));
        baseColor += neon * (mask * 0.45 + edge * 0.8);
        float halo = smoothstep(0.68, 0.08, radius);
        vec3 haloColor = mix(uNeonA, uNeonB, sin(uTime * 1.1 + radius * 12.0) * 0.5 + 0.5);
        baseColor += haloColor * halo * 0.35;
        float alpha = clamp(mask + halo * 0.45, 0.0, 1.0);
        if (alpha < 0.01) discard;
        gl_FragColor = vec4(baseColor, alpha);
      }
    `,
    transparent: true,
    depthWrite: false,
    side: THREE.DoubleSide
  });

  const headingPlane = new THREE.Mesh(new THREE.PlaneGeometry(3.8, 1.28, 1, 1), headingMaterial);
  headingPlane.renderOrder = 2;
  headingPlane.userData.basePosition = new THREE.Vector3(0, 0.78, 1.35);
  headingPlane.userData.baseScale = new THREE.Vector2(1.08, 0.96);
  headingPlane.scale.set(headingPlane.userData.baseScale.x, headingPlane.userData.baseScale.y, 1);
  scene.add(headingPlane);
  if (headingElement) {
    headingElement.classList.add('is-ghosted');
  }

  function updateHeadingLayout(){
    if (!headingPlane) return;
    const portrait = window.innerHeight > window.innerWidth;
    const basePosition = headingPlane.userData.basePosition;
    const baseScale = headingPlane.userData.baseScale;
    basePosition.set(0, portrait ? 0.92 : 0.78, portrait ? 1.55 : 1.35);
    baseScale.set(portrait ? 0.92 : 1.08, portrait ? 1.18 : 0.96);
    headingPlane.scale.set(baseScale.x, baseScale.y, 1);
  }

  updateHeadingLayout();

  const ambient = new THREE.AmbientLight(0x10263b, 0.9);
  const hemisphere = new THREE.HemisphereLight(0x1a4872, 0x01040a, 0.6);
  const keyLight = new THREE.PointLight(0x14a7ff, 2.2, 24, 1.7);
  keyLight.position.set(3.6, 2.8, 4.3);
  const rimLight = new THREE.PointLight(0x0fffd7, 1.5, 20, 1.6);
  rimLight.position.set(-3.4, -1.2, -2.6);
  scene.add(ambient, hemisphere, keyLight, rimLight);

  const searchlightGroup = new THREE.Group();
  const searchlightRigs = [];
  const searchlightColors = [0x12e9ff, 0x1ab5ff, 0x25ffd6];
  searchlightColors.forEach((color, index) => {
    const rig = new THREE.Group();
    const angle = (index / searchlightColors.length) * Math.PI * 2;
    rig.position.set(Math.cos(angle) * 4.8, 1.1 + Math.sin(angle * 1.5) * 0.4, Math.sin(angle) * 4.8);

    const target = new THREE.Object3D();
    target.position.set(0, -1.5, 0);
    rig.add(target);

    const spotlight = new THREE.SpotLight(color, 3.4, 20, Math.PI / 5.4, 0.52, 1.6);
    spotlight.position.set(0, 0, 0);
    spotlight.target = target;
    rig.add(spotlight);

    const beam = new THREE.Mesh(
      new THREE.ConeGeometry(0.95, 6.8, 48, 1, true),
      new THREE.MeshBasicMaterial({
        color,
        transparent: true,
        opacity: 0.2,
        blending: THREE.AdditiveBlending,
        depthWrite: false,
        side: THREE.DoubleSide
      })
    );
    beam.position.set(0, -3.4, 0);
    beam.rotation.x = Math.PI;
    rig.add(beam);

    searchlightRigs.push({ rig, spotlight, beam, target, phase: Math.random() * Math.PI * 2 });
    searchlightGroup.add(rig);
  });
  scene.add(searchlightGroup);

  const glimmerCount = isMobile ? 780 : 1400;
  const glimmerGeometry = new THREE.BufferGeometry();
  const glimmerPositions = new Float32Array(glimmerCount * 3);
  for (let i = 0; i < glimmerCount; i++) {
    const radius = 10 + Math.random() * 18;
    const theta = Math.random() * Math.PI * 2;
    const phi = Math.acos(2 * Math.random() - 1);
    glimmerPositions[i * 3] = radius * Math.sin(phi) * Math.cos(theta);
    glimmerPositions[i * 3 + 1] = radius * Math.cos(phi) * 0.7;
    glimmerPositions[i * 3 + 2] = radius * Math.sin(phi) * Math.sin(theta);
  }
  glimmerGeometry.setAttribute('position', new THREE.Float32BufferAttribute(glimmerPositions, 3));
  const glimmerMaterial = new THREE.PointsMaterial({
    color: 0x5cf7ff,
    size: 0.06,
    sizeAttenuation: true,
    transparent: true,
    opacity: 0.85,
    depthWrite: false,
    blending: THREE.AdditiveBlending
  });
  const glimmerField = new THREE.Points(glimmerGeometry, glimmerMaterial);
  scene.add(glimmerField);

  const backdrop = new THREE.Mesh(
    new THREE.SphereGeometry(55, 48, 48),
    new THREE.MeshBasicMaterial({ color: 0x010307, side: THREE.BackSide, fog: false })
  );
  scene.add(backdrop);

  const portalMaterial = new THREE.ShaderMaterial({
    uniforms: {
      uTime: { value: 0 },
      uColor1: { value: new THREE.Color(0x022c45) },
      uColor2: { value: new THREE.Color(0x16ffe3) }
    },
    vertexShader: `
      varying vec2 vUv;
      uniform float uTime;
      void main(){
        vUv = uv;
        float pulse = sin((uv.x + uv.y + uTime * 0.6) * 7.0);
        vec3 displaced = position + normal * (0.18 + pulse * 0.04);
        gl_Position = projectionMatrix * modelViewMatrix * vec4(displaced, 1.0);
      }
    `,
    fragmentShader: `
      varying vec2 vUv;
      uniform float uTime;
      uniform vec3 uColor1;
      uniform vec3 uColor2;
      void main(){
        float wave = sin((vUv.x * 2.2 + vUv.y * 2.8 + uTime * 1.1) * 4.0);
        float radial = smoothstep(1.0, 0.22, length(vUv - 0.5));
        vec3 color = mix(uColor1, uColor2, clamp(vUv.y + wave * 0.1, 0.0, 1.0));
        color += radial * 0.45;
        gl_FragColor = vec4(color, radial);
      }
    `,
    transparent: true,
    side: THREE.DoubleSide
  });
  const portal = new THREE.Mesh(new THREE.RingGeometry(1.4, 2.4, 128, 48), portalMaterial);
  portal.rotation.x = Math.PI / 2;
  scene.add(portal);

  const torus = new THREE.Mesh(
    new THREE.TorusKnotGeometry(1, 0.32, 320, 48, 2, 5),
    new THREE.MeshStandardMaterial({
      color: 0x12d8ff,
      metalness: 0.45,
      roughness: 0.22,
      emissive: 0x045d91,
      emissiveIntensity: 1.4
    })
  );
  scene.add(torus);

  const orbGeometry = new THREE.IcosahedronGeometry(0.82, 4);
  const orbMaterial = new THREE.ShaderMaterial({
    uniforms: {
      uSceneTexture: { value: backgroundTarget.texture },
      uStrength: { value: 0.24 },
      uTime: { value: 0 },
      uGlowColor: { value: new THREE.Color(0x1fffe1) },
      uHighlightColor: { value: new THREE.Color(0x1488ff) }
    },
    vertexShader: `
      varying vec3 vWorldPosition;
      varying vec3 vWorldNormal;
      varying vec4 vClipPosition;
      void main(){
        vec4 worldPosition = modelMatrix * vec4(position, 1.0);
        vWorldPosition = worldPosition.xyz;
        vWorldNormal = normalize(mat3(modelMatrix) * normal);
        vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
        vClipPosition = projectionMatrix * mvPosition;
        gl_Position = vClipPosition;
      }
    `,
    fragmentShader: `
      precision highp float;
      varying vec3 vWorldPosition;
      varying vec3 vWorldNormal;
      varying vec4 vClipPosition;
      uniform sampler2D uSceneTexture;
      uniform float uStrength;
      uniform float uTime;
      uniform vec3 uGlowColor;
      uniform vec3 uHighlightColor;
      void main(){
        vec3 normal = normalize(vWorldNormal);
        vec3 viewDir = normalize(cameraPosition - vWorldPosition);
        float viewDot = max(dot(normal, viewDir), 0.0);
        float fresnel = pow(1.0 - viewDot, 2.8);

        vec2 ndc = vClipPosition.xy / vClipPosition.w;
        vec2 uv = ndc * 0.5 + 0.5;
        float distortion = uStrength * (1.0 - pow(viewDot, 1.2));
        vec2 offsetDir = normal.xy;
        float offsetLen = max(length(offsetDir), 0.0001);
        vec2 offset = offsetDir / offsetLen * distortion;
        vec2 sampleUv = clamp(uv + offset, vec2(0.001), vec2(0.999));
        vec3 sceneColor = texture(uSceneTexture, sampleUv).rgb;

        float caustic = sin(uTime * 1.4 + normal.y * 6.0 + normal.x * 3.5) * 0.25 + 0.25;
        vec3 glow = uGlowColor * (0.35 + fresnel * 1.6);
        vec3 highlight = uHighlightColor * (0.2 + caustic * 0.6);
        vec3 color = sceneColor * (0.9 + fresnel * 0.2) + glow * fresnel + highlight * (1.0 - abs(normal.z));
        float alpha = 0.72 + fresnel * 0.25;
        gl_FragColor = vec4(color, alpha);
      }
    `,
    transparent: true
  });

  const orb = new THREE.Mesh(orbGeometry, orbMaterial);
  scene.add(orb);

  const curve = new THREE.CatmullRomCurve3([
    new THREE.Vector3(-0.9, -0.3, -2.6),
    new THREE.Vector3(-0.6, 0.9, -1.4),
    new THREE.Vector3(0.5, 1.3, 0.2),
    new THREE.Vector3(-0.2, 0.1, 1.8),
    new THREE.Vector3(0.7, -0.9, 2.7)
  ], false, 'centripetal', 0.6);
  const ribbon = new THREE.Mesh(
    new THREE.TubeGeometry(curve, 460, 0.1, 32, false),
    new THREE.MeshStandardMaterial({
      color: 0x13ffe6,
      emissive: 0x048cff,
      emissiveIntensity: 2.0,
      metalness: 0.28,
      roughness: 0.18,
      transparent: true,
      opacity: 0.78
    })
  );
  ribbon.rotation.y = Math.PI / 3;
  scene.add(ribbon);

  const neonTubeGroup = new THREE.Group();
  const neonMaterials = [];
  const neonPaths = [
    [
      new THREE.Vector3(-1.6, -1.1, -2.8),
      new THREE.Vector3(-1.1, 0.2, -1.4),
      new THREE.Vector3(-0.4, 0.8, 0.6),
      new THREE.Vector3(0.6, 0.4, 2.1)
    ],
    [
      new THREE.Vector3(1.4, -0.7, -2.4),
      new THREE.Vector3(0.8, 1.1, -0.9),
      new THREE.Vector3(-0.2, 1.4, 0.9),
      new THREE.Vector3(-0.9, 0.2, 2.4)
    ],
    [
      new THREE.Vector3(-0.2, -1.4, -2.2),
      new THREE.Vector3(0.1, -0.2, -0.9),
      new THREE.Vector3(0.5, 0.6, 0.3),
      new THREE.Vector3(0.2, -0.4, 1.9)
    ]
  ];
  const neonColors = [0x0dffe6, 0x13b9ff, 0x19ffd1];
  neonPaths.forEach((points, idx) => {
    const curve3 = new THREE.CatmullRomCurve3(points, false, 'centripetal', 0.7);
    const geometry = new THREE.TubeGeometry(curve3, 300, 0.05 + idx * 0.01, 24, false);
    const color = neonColors[idx % neonColors.length];
    const material = new THREE.MeshStandardMaterial({
      color,
      emissive: color,
      emissiveIntensity: 2.4,
      metalness: 0.15,
      roughness: 0.18,
      transparent: true,
      opacity: 0.85,
      depthWrite: false
    });
    neonMaterials.push(material);
    const mesh = new THREE.Mesh(geometry, material);
    neonTubeGroup.add(mesh);
  });
  neonTubeGroup.rotation.y = Math.PI / 5;
  scene.add(neonTubeGroup);

  const mistCount = isMobile ? 640 : 1100;
  const mistGeometry = new THREE.BufferGeometry();
  const mistPositions = new Float32Array(mistCount * 3);
  const mistVelocities = new Float32Array(mistCount);
  for (let i = 0; i < mistCount; i++) {
    const radius = 4 + Math.random() * 6;
    const angle = Math.random() * Math.PI * 2;
    const idx3 = i * 3;
    mistPositions[idx3] = Math.cos(angle) * radius;
    mistPositions[idx3 + 1] = -0.6 + Math.random() * 3.6;
    mistPositions[idx3 + 2] = -7 - Math.random() * 4;
    mistVelocities[i] = 0.2 + Math.random() * 0.45;
  }
  const mistAttribute = new THREE.BufferAttribute(mistPositions, 3);
  mistGeometry.setAttribute('position', mistAttribute);
  const mistTexture = new THREE.TextureLoader().load('https://cdn.jsdelivr.net/gh/mrdoob/three.js@r161/examples/textures/sprites/smoke.png');
  mistTexture.colorSpace = THREE.SRGBColorSpace;
  const mistMaterial = new THREE.PointsMaterial({
    color: 0x6ef0ff,
    size: 1.4,
    sizeAttenuation: true,
    map: mistTexture,
    transparent: true,
    opacity: 0.22,
    depthWrite: false,
    blending: THREE.AdditiveBlending
  });
  const mistField = new THREE.Points(mistGeometry, mistMaterial);
  mistField.position.y = -0.4;
  scene.add(mistField);

  const neonGridMaterial = new THREE.ShaderMaterial({
    uniforms: {
      uTime: { value: 0 },
      uColorA: { value: new THREE.Color(0x0b8cff) },
      uColorB: { value: new THREE.Color(0x09ffd8) },
      uColorC: { value: new THREE.Color(0x2a9dff) }
    },
    vertexShader: `
      varying vec2 vUv;
      uniform float uTime;
      void main(){
        vUv = uv;
        vec3 pos = position;
        float waveX = sin((pos.x + uTime * 2.4) * 0.7);
        float waveY = cos((pos.y - uTime * 1.6) * 0.9);
        float ripple = sin((pos.x + pos.y) * 0.8 - uTime * 1.8);
        pos.z += waveX * 0.45 + waveY * 0.35;
        pos.z += ripple * 0.22;
        pos.y += sin(uTime * 0.8 + pos.x * 0.4) * 0.05;
        gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
      }
    `,
    fragmentShader: `
      varying vec2 vUv;
      uniform float uTime;
      uniform vec3 uColorA;
      uniform vec3 uColorB;
      uniform vec3 uColorC;
      void main(){
        vec2 grid = fract(vUv * 12.0);
        float line = min(min(grid.x, 1.0 - grid.x), min(grid.y, 1.0 - grid.y));
        float glow = smoothstep(0.08, 0.0, line);
        float pulse = sin(uTime * 2.0 + vUv.x * 10.0) * 0.5 + 0.5;
        vec3 color = mix(uColorA, uColorB, pulse);
        color = mix(color, uColorC, sin(uTime + vUv.y * 8.0) * 0.5 + 0.5);
        gl_FragColor = vec4(color * (0.4 + glow * 1.6), glow * 0.85);
      }
    `,
    transparent: true,
    depthWrite: false,
    blending: THREE.AdditiveBlending
  });
  const neonGrid = new THREE.Mesh(new THREE.PlaneGeometry(28, 28, 140, 140), neonGridMaterial);
  neonGrid.rotation.x = -Math.PI / 2;
  neonGrid.position.set(0, -2.6, 0);
  scene.add(neonGrid);
  const neonGridMaterial2 = neonGridMaterial.clone();
  neonGridMaterial2.uniforms = THREE.UniformsUtils.clone(neonGridMaterial.uniforms);
  const neonGrid2 = new THREE.Mesh(new THREE.PlaneGeometry(24, 24, 120, 120), neonGridMaterial2);
  neonGrid2.rotation.x = -Math.PI / 2;
  neonGrid2.rotation.z = Math.PI / 6;
  neonGrid2.position.set(0, -3.4, -5.5);
  scene.add(neonGrid2);

  const clock = new THREE.Clock();
  let elapsedTime = 0;
  let isPaused = false;
  let smoothedFps = 0;
  let lastFpsUpdate = 0;
  const portalFocus = new THREE.Vector3(0, -0.05, 0);

  function resizeRenderer(){
    const width = window.innerWidth;
    const height = window.innerHeight;
    renderer.setSize(width, height, false);
    camera.aspect = width / height;
    camera.updateProjectionMatrix();
    const ratio = renderer.getPixelRatio();
    backgroundTarget.setSize(width * ratio, height * ratio);
    updateHeadingLayout();
  }

  function applyResolution(value){
    currentResolution = value;
    const ratio = value === 'auto' ? pixelRatioLimits.auto() : pixelRatioLimits.fixed(parseFloat(value));
    renderer.setPixelRatio(ratio);
    resizeRenderer();
  }

  const handleResize = () => {
    applyResolution(currentResolution);
  };
  window.addEventListener('resize', handleResize, { passive: true });

  const handleOrientationChange = () => {
    requestAnimationFrame(() => applyResolution(currentResolution));
  };
  if (screen.orientation && typeof screen.orientation.addEventListener === 'function') {
    screen.orientation.addEventListener('change', handleOrientationChange);
  } else {
    window.addEventListener('orientationchange', handleOrientationChange);
  }

  const updateMobileFlag = (event) => {
    isMobile = uaIsMobile || (event ? event.matches : mobileQuery.matches);
    applyResolution(currentResolution);
  };
  if (typeof mobileQuery.addEventListener === 'function') {
    mobileQuery.addEventListener('change', updateMobileFlag);
  } else if (typeof mobileQuery.addListener === 'function') {
    mobileQuery.addListener(updateMobileFlag);
  }

  function animate(){
    const frameDelta = clock.getDelta();
    const now = performance.now();
    const frameFps = frameDelta > 0 ? 1 / frameDelta : 0;
    smoothedFps = smoothedFps ? smoothedFps * 0.9 + frameFps * 0.1 : frameFps;
    if (fpsValue && now - lastFpsUpdate > 160) {
      const display = Math.round(smoothedFps);
      fpsValue.textContent = display.toString().padStart(2, '0');
      if (fpsCounter) {
        fpsCounter.setAttribute('aria-label', `Frame rate ${display} frames per second`);
      }
      lastFpsUpdate = now;
    }
    const delta = isPaused ? 0 : frameDelta;
    if (!isPaused) {
      elapsedTime += delta;
    }
    const t = elapsedTime;
    headingMaterial.uniforms.uTime.value = t;
    portalMaterial.uniforms.uTime.value = t;
    orbMaterial.uniforms.uTime.value = t;
    neonGridMaterial.uniforms.uTime.value = t * 0.8;
    neonGridMaterial2.uniforms.uTime.value = t * 0.65 + 1.3;

    torus.rotation.x = t * 0.34;
    torus.rotation.z = t * 0.18;
    torus.position.y = Math.sin(t * 0.6) * 0.22;
    torus.material.emissiveIntensity = 1.35 + Math.sin(t * 1.7) * 0.35;

    orb.position.set(Math.sin(t * 1.1) * 1.35, Math.cos(t * 0.8) * 0.6, Math.cos(t * 1.2) * 1.3);
    orb.rotation.y = t * 0.5;
    orb.rotation.x = Math.sin(t * 0.6) * 0.3;

    ribbon.rotation.y = Math.PI / 3 + Math.sin(t * 0.35) * 0.32;
    ribbon.rotation.x = Math.sin(t * 0.26) * 0.18;
    ribbon.material.emissiveIntensity = 1.8 + Math.sin(t * 2.1) * 0.4;

    neonTubeGroup.rotation.y = Math.PI / 5 + Math.sin(t * 0.2) * 0.35;
    neonTubeGroup.rotation.x = Math.sin(t * 0.1) * 0.08;
    neonMaterials.forEach((material, idx) => {
      material.emissiveIntensity = 2.2 + Math.sin(t * 1.5 + idx) * 0.6;
      const opacityPulse = 0.78 + Math.sin(t * 1.1 + idx) * 0.08;
      material.opacity = THREE.MathUtils.clamp(opacityPulse, 0.6, 0.95);
    });

    glimmerField.rotation.y = t * 0.04;
    glimmerField.rotation.x = Math.sin(t * 0.05) * 0.08;

    searchlightGroup.rotation.y = Math.sin(t * 0.18) * 0.4;
    searchlightRigs.forEach((entry) => {
      entry.rig.rotation.y += delta * 0.35;
      entry.rig.rotation.x = Math.sin(t * 0.42 + entry.phase) * 0.22;
      entry.spotlight.intensity = 2.6 + Math.sin(t * 1.5 + entry.phase) * 0.9;
      entry.beam.material.opacity = 0.17 + Math.sin(t * 1.2 + entry.phase) * 0.1;
      entry.target.position.x = Math.sin(t * 0.6 + entry.phase) * 0.7;
      entry.target.position.y = -1.5 + Math.cos(t * 0.7 + entry.phase) * 0.35;
    });

    keyLight.intensity = 2.2 + Math.sin(t * 1.9) * 0.5;
    rimLight.intensity = 1.5 + Math.cos(t * 1.6) * 0.45;
    hemisphere.intensity = 0.6 + Math.sin(t * 0.9) * 0.08;

    for (let i = 0; i < mistCount; i++) {
      const idx3 = i * 3;
      mistPositions[idx3 + 2] += mistVelocities[i] * delta;
      mistPositions[idx3] += Math.sin(t * 0.5 + mistPositions[idx3 + 2] * 0.3) * delta * 0.6;
      mistPositions[idx3 + 1] += Math.cos(t * 0.4 + mistPositions[idx3]) * delta * 0.3;
      if (mistPositions[idx3 + 2] > 5) {
        const radius = 4 + Math.random() * 6;
        const angle = Math.random() * Math.PI * 2;
        mistPositions[idx3] = Math.cos(angle) * radius;
        mistPositions[idx3 + 1] = -0.6 + Math.random() * 3.6;
        mistPositions[idx3 + 2] = -7 - Math.random() * 4;
        mistVelocities[i] = 0.2 + Math.random() * 0.45;
      }
    }
    if (delta > 0) {
      mistAttribute.needsUpdate = true;
    }

    const camRadius = 0.9 + Math.sin(t * 0.15) * 0.1;
    camera.position.x = Math.sin(t * 0.23) * camRadius;
    camera.position.y = 0.4 + Math.sin(t * 0.32) * 0.24;
    camera.position.z = 5.3 + Math.cos(t * 0.17) * 0.45;
    camera.lookAt(0, -0.05, 0);

    const lensStrength = THREE.MathUtils.clamp(1 - orb.position.distanceTo(portalFocus) / 3.2, 0, 1);
    headingMaterial.uniforms.uLensIntensity.value = lensStrength;
    if (headingPlane) {
      const basePosition = headingPlane.userData.basePosition;
      const baseScale = headingPlane.userData.baseScale;
      headingPlane.position.set(
        basePosition.x + Math.sin(t * 0.22) * 0.18,
        basePosition.y + Math.sin(t * 0.34) * 0.06,
        basePosition.z + Math.cos(t * 0.21) * 0.08
      );
      const scalePulse = 1 + Math.sin(t * 0.42) * 0.04;
      headingPlane.scale.set(baseScale.x * scalePulse, baseScale.y * scalePulse, 1);
      headingPlane.quaternion.copy(camera.quaternion);
      headingPlane.rotateX(-0.26);
      headingPlane.rotateY(Math.sin(t * 0.18) * 0.05);
    }

    const headingVisible = headingPlane.visible;
    orb.visible = false;
    headingPlane.visible = false;
    renderer.setRenderTarget(backgroundTarget);
    renderer.render(scene, camera);
    renderer.setRenderTarget(null);
    orb.visible = true;
    headingPlane.visible = headingVisible;

    renderer.render(scene, camera);
    requestAnimationFrame(animate);
  }

  resolutionSelect.addEventListener('change', () => {
    applyResolution(resolutionSelect.value);
  });
  applyResolution(resolutionSelect.value);

  fullscreenToggle.addEventListener('click', () => {
    if (!document.fullscreenElement) {
      document.documentElement.requestFullscreen().then(() => {
        fullscreenToggle.textContent = 'Exit fullscreen';
      }).catch(() => {});
    } else {
      document.exitFullscreen().catch(() => {}).finally(() => {
        fullscreenToggle.textContent = 'Enter fullscreen';
      });
    }
  });

  document.addEventListener('fullscreenchange', () => {
    fullscreenToggle.textContent = document.fullscreenElement ? 'Exit fullscreen' : 'Enter fullscreen';
  });

  let gyroBaseline = null;
  let gyroActive = false;
  let lastOrientationEvent = 0;
  function updateStatus(message){
    statusLine.textContent = message;
  }
  function onOrientation(event){
    gyroActive = true;
    lastOrientationEvent = performance.now();
    if (!gyroBaseline) {
      gyroBaseline = { alpha: event.alpha, beta: event.beta, gamma: event.gamma };
      updateStatus('Gyroscope calibrated');
    }
  }
  let orientationListenerAttached = false;
  gyroButton.addEventListener('click', async () => {
    function attachListener(){
      if (!orientationListenerAttached) {
        window.addEventListener('deviceorientation', onOrientation, { passive: true });
        orientationListenerAttached = true;
      }
      gyroBaseline = null;
      updateStatus('Calibrating… move device gently');
    }
    if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {
      try {
        const permission = await DeviceOrientationEvent.requestPermission();
        if (permission === 'granted') {
          attachListener();
        } else {
          updateStatus('Gyroscope permission denied');
        }
      } catch (err) {
        updateStatus('Gyroscope unavailable');
      }
    } else if ('DeviceOrientationEvent' in window) {
      attachListener();
    } else {
      updateStatus('Gyroscope not supported');
    }
  });

  document.addEventListener('keydown', (event) => {
    if (event.code === 'Space') {
      event.preventDefault();
      isPaused = !isPaused;
      updateStatus(isPaused ? 'Motion paused' : 'Motion resumed');
    }
  });

  setInterval(() => {
    if (gyroActive && performance.now() - lastOrientationEvent > 5000) {
      gyroActive = false;
      updateStatus('Gyroscope idle');
    }
  }, 4000);

  animate();
});
</script>
</body>
</html>
